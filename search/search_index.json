{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"clojure-lsp # A Language Server for Clojure(script). Taking a Cursive-like approach of statically analyzing code. homepage \u2022 features \u2022 installation \u2022 settings \u2022 clients \u2022 troubleshooting \u2022 support us Overview # The goal of this project is to bring great editing tools for Clojure/Clojurescript to all editors. It aims to work alongside you to help you navigate, identify and fix errors, perform refactors and much more! You will get: Autocomplete Jump to definition Find references Renaming Code actions Errors Automatic ns management Refactorings Code lens Semantic tokens (syntax highlighting) Call hierarchy For all available documentation, check the official website . Also, clojure-lsp doesn't need to run in a editor, for more information check the API documentation section . Contribution # Contributions to clojure-lsp are very welcome! You can open an issue or a PR and we'd love to help. Support the project # clojure-lsp has more than 12.000 lines of code, to keep all of this working, we need to help the community on a lot of issues and implement new features. As a LSP server, this project is the base for Clojure clients like Emacs(lsp-mode), VSCode(Calva), vim and other editors. You can help us keep going and improving it by supporting the project Thank you to Clojurists Together which is sponsoring this project during Q3 2021 Gold sponsors # pitch-io Pitch Sponsors # Special thanks to Eccentric-J for the clojure-lsp logo","title":"Overview"},{"location":"#clojure-lsp","text":"A Language Server for Clojure(script). Taking a Cursive-like approach of statically analyzing code. homepage \u2022 features \u2022 installation \u2022 settings \u2022 clients \u2022 troubleshooting \u2022 support us","title":"clojure-lsp"},{"location":"#overview","text":"The goal of this project is to bring great editing tools for Clojure/Clojurescript to all editors. It aims to work alongside you to help you navigate, identify and fix errors, perform refactors and much more! You will get: Autocomplete Jump to definition Find references Renaming Code actions Errors Automatic ns management Refactorings Code lens Semantic tokens (syntax highlighting) Call hierarchy For all available documentation, check the official website . Also, clojure-lsp doesn't need to run in a editor, for more information check the API documentation section .","title":"Overview"},{"location":"#contribution","text":"Contributions to clojure-lsp are very welcome! You can open an issue or a PR and we'd love to help.","title":"Contribution"},{"location":"#support-the-project","text":"clojure-lsp has more than 12.000 lines of code, to keep all of this working, we need to help the community on a lot of issues and implement new features. As a LSP server, this project is the base for Clojure clients like Emacs(lsp-mode), VSCode(Calva), vim and other editors. You can help us keep going and improving it by supporting the project Thank you to Clojurists Together which is sponsoring this project during Q3 2021","title":"Support the project"},{"location":"#gold-sponsors","text":"pitch-io Pitch","title":"Gold sponsors"},{"location":"#sponsors","text":"Special thanks to Eccentric-J for the clojure-lsp logo","title":"Sponsors"},{"location":"CHANGELOG/","text":"Changelog # Unreleased # General Bump Graalvm from 21.2.0 to 21.3.0 improving binary performance/size Fix wrong parse of code when code contains namespaced maps like #:foo{:bar 1} . This issue was affecting a lot of features for example code actions. Bump datalevin from 0.5.26 to 0.5.27. Improve semantic tokens for dynamic vars, function definitions, namespaced and aliased keywords. Fix bug where :source-paths settings could be hot-reloaded with wrong-value. Add support for window/showDocument LSP method, used on create-test command/code action after creating the test to show the test file. Editor Deprecates setting :show-docs-arity-on-same-line? in favor of :hover :arity-on-same-line? . Add support to new LSP LinkedEditingRange feature. #341 Improve suggested Add require ... code actions, this should make clojure-lsp smarter when user wants to add a missing require. #614 Change :notify-references-on-file-change default from false to true , we had some performance improvements and I've been testing this for some time now and didn't see any new issues with that. This should improve a lot the UX when user change any code that is references on other files, updating the diagnostics for those files as well. Improve rename feature UX to output errors when it's not possible rename. Add new Unwind thread once and Unwind whole thread code actions to undo a thread call. Improve code actions performance request async all actions. 2021.10.20-16.49.47 # Editor Hot fix clojuredocs on graalvm native image. Bump clj-kondo to 2021.10.20-20211020.123254-3 to fix a specific issue with cljs. Implement support to return to client LSP Errors, making user UX better since clojure-lsp can return specific errors for specific exceptions. 2021.10.20-13.04.11 # General Improve intialization feedback report messages. Consider dev and test alias for deps.edn projects as project-specs during classpath lookup. #586 Avoid scanning source-paths twice, as it was being considered as part of external classpath as well. Change cache db from sqlite to datalevin for faster startup + better graalvm compatibility. Make the cache analysis save async to make startup faster. Support Auto refresh settings memoizing with a ttl of 1 second avoiding the need of restarting server when changing configs. #502 Bump clj-kondo adding new gen-class linter and other fixes/improvements. Fixes #589 Remove unused duplicate require if any. #527 Fix crash on clean-ns when ns contains comments. Improve project analysis filter to check source-paths. #597 Editor Add reference code lens for ns forms. #578 Fix expand-let bug that occurs when a list form precedes let. #590 Add new command to create test for function at point. #582 Add new code action to create test for current function/var Add private to documentSymbol to make clear that a var or function is private . Add new code action Suppress xxx diagnostic , adding clj-kondo comment code to ignore the diagnostic. #591 Add more semantic tokens: aliases for macros, variable and function definitions. Add clojuredocs information during symbol hover. #571 This release was supported by Clojurists Together 2021.09.30-15.28.01 # Editor Hot fix hover content wrong type hinting. 2021.09.30-12.28.16 # General Use lower-case for refer/import/require sorting. #560 #561 Avoid removing comments when sorting/cleaning namespace. #559 Break lines when sorting refers along with then new :clean :sort :refer :max-line-length setting with a default of 80 . #562 Deprecate lens-segregate-test-references in favor to :code-lens :segregate-test-references Check for a default .cljfmt.edn config file for cljfmt config settings if no :cljfmt-config-path was provided. #563 Bump clj-kondo to 2021.09.25 fixing false-positives with potemkin import-var analysis. Re-scan whole project if any clj-kondo config changed for better consistence. #331 Fix clojure-lsp not initializing when empty project.clj . #579 Support finding config in classpath via new setting :classpath-config-paths [\"my-org/my-lib\"] . #580 Editor Fix resolve macro as code action after regression introduced recently. Fix unused-public-var not being suppressed during project startup. #554 Improve hover feature to return elements when inside a function call. #569 Fix create-private-function command and code action to consider when new function is inside thread macros. Support $/progress LSP feature, sending notifications for client when server is starting, improving the feedback for the user. Improve semantic tokens support for java classes and methods. API/CLI Support renaming namespaces as well with rename feature. Use relative paths instead of absolute paths on diff messages. Add analyze-project! to analyze whole project only and cache analysis, useful for REPL usage for example. Follow same exit status from clj-kondo for diagnostics feature. #572 Improve start project feedback reporting the percentage and specific message. This release was supported by Clojurists Together 2021.09.13-22.25.35 # Editor Rollback change on didChangeWatchedFiles for :change events, avoiding outdated changes overwriting newer changes. 2021.09.13-19.32.00 # General Create .clj-kondo folder if not exists in project root. #528 Fix exception when :clojure-lsp/unused-public-var linter is :off . #546 Bump clj-kondo to 2021.08.07-20210903.210340-28 to fix a false-positive with potemkin. https://github.com/clj-kondo/clj-kondo/issues/1370. Bump clj-kondo to 2021.08.07-20210909.131804-29 fixing issues with built-in clj-kondo cache not present on graalvm binaries. #548 Exclude cljs.test/deftest from unused public vars linter. Migrate default db file from .lsp/sqlite.db to .lsp/.cache/sqlite.db , this is necessary as in the future we will replace sqlite with other db implementation, for users they just need to consider/gitignore the .lsp/.cache folder, this way any next change on db implementations or any other cache will not affect user. Auto migrate existing .lsp/sqlite.db to new .lsp/.cache/sqlite.db to avoid unnecessary project re-scan. Deprecates :sqlite-db-path in place of :cache-path . Editor Fix didChangeWatchedFiles to correctly create the file on server, properly change file content and re-scan with clj-kondo, or remove file analysis. This should improve LSP analysis reliability when changing files outside the editor. #536 Improve completion only showing valid local vars for current cursor. Improve completion sorting adding priority to each item, showing most used symbols like variables and functions first before other completion items. API/CLI New diagnostics command, which return all diagnostics found by clojure-lsp (using clj-kondo). Check the API section for more details. This release was supported by Clojurists Together 2021.09.04-17.11.44 # Hotfix java classes not present on jar, required for clojure-lsp downstreams. 2021.09.03-00.42.46 # General Improve logging during startup for better troubleshooting. Refactor allowing calls to clojure-lsp.main/run! for manually passing args, useful for lein-clojure-lsp for example. Internal: Move graalvm configuration to sqlite-jdbc. Recognize deftest as function definition form for refactoring features like extract-function . Bump Graalvm from 21.1.0 to 21.2.0 API/CLI Use clj-kondo custom lint for API as well, required for correct diagnostics API feature. Editor Fix regression, custom source-paths from initializationOptions were not being parsed correctly. #537 Documentation New domain for documentation and webpage https://clojure-lsp.io 2021.08.24-14.41.56 # General Fix classpath scan when classpath has other things like new lines or warning message besides the classpath. Fixes #523 Improve clean-ns to remove empty reader conditionals( #?(:clj) or #?@(:clj []) on ns form) after cleaning requires/imports. Fix clean-ns false-positives removals to cljc files when the alias/refer/import is being used inside a reader conditional. Add new setting :linters :clj-kondo :ns-exclude-regex which allows exclude diagnostics/findings for namespaces matching that regex. Fix merge of configs resolved for projects with multiple configurations in parent folders and subprojects. Docs Improved the settings docs with a new link to a file with all available clojure-lsp settings. 2021.08.16-19.02.30 # Fix clojure-lsp --version 2021.08.16-14.47.54 # General Fix wrong parse of source-paths for bb.edn when :paths contains symbols not only strings. #507 Bump clj-kondo to fix a issue with clojure-lsp running in a lein process. Editor Fix find-definition in jars for cljc files where the var is available on both cljs and clj files. #509 Add clojure.core.async common vars to common-refers to be required via code action. Remove diagnostics when files are deleted, properly cleaning server. #513 Don't add ns form to blank edn files. #515 Fix initializationOptions parsing for some clients. #516 Fix refactor 'add missing refer' when there is already that namespace with a alias but no refers. Improve :notify-references-on-file-change performance and use-cases, still disabled by default for some time. API Rollback printing only via CLI to work with API as well. (can be disabled via :raw? option) Support for release of lein-clojure-lsp 2021.08.05-19.36.09 # Bump clj-kondo to fix window path issues with analysis. Fix issue with references code lens for vim. 2021.08.05-18.25.54 # Fix async project lint after startup for huge projects. #506 Fix :lint-project-files-after-startup? to be considered before clojure-lsp lint unusued public vars. Fix excluded symbols for code lens, making clojure-lsp check clj-kondo config as well for the :clojure-lsp/unused-public-var excludes 2021.08.03-13.33.03 # General Parse correctly unescaped URIs sent from clients like vim avoiding errors on some features. Bump clj-kondo fixing analysis position issue with declare , making rename and other features work. Don't use PowerShell profiles on Windows when analyzing classpath. Fixes https://github.com/BetterThanTomorrow/calva/issues/1050 Support babashka classpath and source-paths discovery via bb.edn file. (needs babashka >= 0.5.1) Editor Add :hover :hide-file-location? settings option to disable displaying the source path on hover. Use new clj-kondo :custom-lint-fn for the :unused-public-var , this should improve performance and give the ability to suppress unused vars via code with #_{:clj-kondo/ignore [:clojure-lsp/unused-public-var]} or #_:clj-kondo/ignore 2021.07.28-14.24.06 # General Minor fix on the analysis queries comparison. Improve GraalVM configuration to use direct/less configurations. Bump clj-kondo 2021.06.18 -> 2021.07.28 which adds support for macroexpanding. Editor Fix outgoing/incoming call hierarchy when vars are outside project/external jars. Fix completion of aliases without var names typed yet, for example: string/ API/CLI Fix filename in diffs with dry option. Add coloring to diffs following git diff. Add ns-exclude-regex for commands that check whole project, allowing to exclude certain namespaces via regex. 2021.07.19-14.46.52 # General clean-ns now sorts ns children forms according to the ClojureStyleGuide, at the moment moving require form before import form, enabled by default under flag :clean :sort :ns setting. Improve startup error handler and logging during project analysis. Related to #484 Performance improvements using transducers on analysis queries. Fixed auto-resolve source-paths for lein projects that get source-paths dynamically, clojure-lsp will use the default source-paths for these cases Editor Improve hover output, both markdown and plain text forms. Allow calling thread-first/last and thread-first-all/last-all from within the list. Improve resolve-macro-as messages and default excluded symbols. API/CLI Fix empty XDG_CONFIG_HOME not defaulting to $HOME/.config #474 Improve verbose logging setting. 2021.07.12-12.30.59 # Editor Make semantic-tokens return no token for unknown symbols which has :clj-kondo/unknown-namespace on its analysis. Fix file uri location when hovering a symbol. Add reference code lens to keyword definitions, e.g. re-frame.core/reg-sub . Add semantic-tokens debug information to cursor-info response. API/CLI Fix when ns form does not match filename. #466 Fix errors with project-root on graalvm binary Improve API usage avoiding exceptions and returning just data instead. Improve analysis cache to multiple API calls. Add new --raw option allowing to display only raw data. Useful to integrate with other tools like reviewdog. 2021.07.05-20.31.12 # API/CLI Add --verbose option for debugging purposes. Fix usage as library parsing :exec-args correctly 2021.07.05-15.12.14 # General Add :clean :sort settings option to disable sorting during clean-ns . Add :keep value to :ns-indent-blocks-indentation setting to don't change indentation during clean-ns . Deprecate install-latest-clojure-lsp.sh in place of install new script. Improve source paths discoverability for leiningen projects following the same rules as deps.edn projects. For more information, check the settings section . API/CLI Add --dry option to commands, useful to print only diffs instead of making changes. Check the new setup-clojure-lsp Github Action to run clojure-lsp on CI. Add format feature using cljfmt. Now, every release is available in clojars as com.github.clojure-lsp/clojure-lsp . 2021.07.01-19.49.02 # Fix --project-path option for API. Add --log-path option to API. 2021.07.01-13.46.18 # Fix find-references and references lens for defrecord . Improve clean-ns refactoring following the Clojure style guide. Fix clean-ns corner case issue where it would replace the :as value with the :refer value. Deprecate :keep-require-at-start? in favor of :clean :ns-inner-blocks-indentation with default value of :next-line . Bump org.xerial/sqlite-jdbc from 3.34.0 to 3.36.0. Avoid adding duplicated namespace for new blank files. Add API / CLI support, form more information check the API section. 2021.06.24-14.24.11 # Fix missing LSP 3.16 graalvm reflection configs. #452 2021.06.24-01.20.01 # Fix graalvm reflect config for LSP 3.16 protocol. #449 Use last definition when showing signature help. #446 Create 2 new LSP custom methods: clojure/serverInfo/raw and clojure/serverInfo/log deprecating old commands server-info and cursor-info , check the documentation for more information. Add :final-settings to serverInfo methods. #450 2021.06.21-14.30.54 # Avoid removing whole require if unused refer but with used alias during clean-ns. #447 Bump cljfmt 0.7.0 -> 0.8.0. Fixes #266 Bump clj-kondo 2021.06.01 -> 2021.06.18 2021.06.14-17.00.47 # Improve source paths discoverability for deps.edn projects. Adds :source-aliases for customization. For more information, check the settings section . 2021.06.01-16.19.44 # Fix graalvm issue on completionItem InsertTextMode Bump clj-kondo and rewrite-clj to latest releases. 2021.05.27-17.42.34 # Fix corner case error with project paths with spaces or other special characters. #437 Drastically improve didOpen performance, improving kondo findings parsing and making linting async avoiding blocking some editors. #435 Fix :auto-add-ns-to-new-files? flag always being considered as true . #436 2021.05.22-16.50.45 # Fix completion item kind of clojure core items. Fixes #426 Fix graalvm reflect config for SublimeText - #430 Improve code lens for segregated code lens when on test files. 2021.05.14-15.26.02 # Include non full qualified vars on unused-public-var exclude filter. Improve hover documentation: use correct markdown for docstrings; remove unnecessary new lines; add link to filename location. Rollback full text changes on last release and change approach for a temporary fix. #424 2021.05.06-19.44.00 # Quick fix full text changes to handle it sync for semantic tokens Segregate main references from test references with option to disable via lens-segregate-test-references 2021.04.27-20.17.45 # Significantly improve the performance of workspace symbol filtering/searching. See relevant commit . Always sort refers when clean-ns. Add support for installing with homebrew on Linux. Bump clj-kondo to 2021.04.24-20210426.144134-2 adding support for finding re-frame by keyword. Fixes #411 Fix find definition going to declare - Fixes #340 Remove common already known clojure macros from Resolve macro as code action. 2021.04.23-15.49.47 # Improve resolve-macro-as command to check and log if couldn't resolve the macro. Improve workspace symbol filtering/searching. Now, the sole candidates shown are guaranteed to include all the characters contained in the filter/search string. Add more tokens to semantic tokens: keywords, functions/var usages, java classes, local variables. Bump Graalvm from 21.0.0 to 21.1.0 Bump clj-kondo to 2021.04.23 fixing some keywords corner cases. 2021.04.13-12.47.33 # Add common snippets on completion. Check all available snippets here . Add support for custom snippets via :additional-snippets . Check here for more information. - Fixes #403 Bump lsp4j from 0.11.0 -> 0.12.0 2021.04.07-16.34.10 # Fix renaming keywords in cljc files producing duplicate edits. After project startup, publish all project only diagnostics. This is a approach done by other LSPs to make work features like Project errors . Feature flag via lint-project-files-after-startup? with default true . Add experimental support for aarch64 linux native binary Fix formatting issues with a regression introduced on a previous release. - Fixes #339 and #396 2021.04.03-18.43.55 # Fix textDocument/workspaceSymbols filter not working on native binaries. Report duplicate linters as default, can be disabled via :linters :clj-kondo :report-duplicates - Fixes #390 Bump rewrite-clj to 1.0.605-alpha to fix exceptions when on clojure files with babashka interpreter on first line. Bump clj-kondo 2021.04.01-20210402.215253-6 to fix bug https://github.com/clj-kondo/clj-kondo/issues/1246 2021.03.30-20.42.34 # Bump clj-londo 2021.03.22-20210327.192113-4 - Fixes #385 Add support for outgoing call hierarchy - Fixes #384 Improve and fix missing completion item kinds. 2021.03.26-23.41.07 # Bump clj-kondo 2021.03.22-20210324.110254-3 - Fixes #382 [graalvm] Fixes Unable to invoke no-args constructor for class org.eclipse.lsp4j.ShowDocumentCapabilities error. Fix/enhance keyword rename - #383 2021.03.24-00.41.55 # Migrate from lein to deps.edn Bump clj-kondo to 2021.03.22 Fix clean-ns sorting according to symbols not brackets - Fixes #380 Fix missing graalvm reflect config for CompletionItemTextEdit - Fixes #381 2021.03.21-23.29.19 # Add code action 'resolve macro as', it requires client to fill the chosen macro and clj-kondo config file. Bump rewrite-clj to 1.0.594-alpha Bump data.json to 2.0.1 Bump lsp4j to 0.11.0 2021.03.18-19.23.41 # Add support for diagnostic tags: deprecated and unnecessary. Fix wrong textDocument/documentHighlight for function local-usages. Use new clj-kondo copy-configs flag to copy hooks during lint. Bunp clj-kondo to fix unused public linter check for :exclude-when-defined-by 2021.03.16-20.28.06 # Fix server not analyzing after a wrong code on cljs files - #367 Rollback incremental didChange adding a new :text-document-sync-kind setting with :full as default. 2021.03.14-23.22.46 # Fix completion inside refers, re-add support for it - Fixes #364 Change range of expression functions clj-kondo diagnostics to avoid collision with function signature. 2021.03.06-17.05.35 # Fix incremental didChange, debouncing distincting by uri, fixing some inconsistent file changes when multiple files are changed at same time (rename, iedit, etc). Make unused-public-var ignore -main public functions. Add :exclude-when-defined-by option to unused-public-var linter, check settings documentation for more information. 2021.03.05-13.35.47 # Fix clojure-lsp lint crash when analyzing specific macros with clj-kondo hooks. Fix didChange for Nvim client. Add new clojure-lsp linter: unused-public-var - Fixes #359 Add option to disable clj-kondo linter, check settings documentation for more details. 2021.03.01-19.18.54 # Bump clj-kondo fixing issues on require form not being analyzed. Fix textDocument/workspaceSymbols to use the query sent by client. 2021.02.27-23.35.55 # Add support to complete full qualified namespaces - Fixes #337 Add :log-path setting to log to a custom file. Avoid exception on code actions when on cljc reader macros - Related to #346 2021.02.26-13.58.48 # Improve clojure-lsp config search checking always home dir considering XDG_CONFIG_HOME and project root up to system root (/) - Fixes #339. Handle incremental text changes on textDocument/didChange notifications following LSP protocol, improving performance for huge files. Add clj-kondo version to --version and server-info. Add new create private function code action. 2021.02.24-14.23.08 # Improve completion performance resolving the item only when documentation is requested Add new thread first/last all code actions 2021.02.21-21.02.51 # Implement support for textDocument/signatureHelp - Fixes #324 Disable notify-references on didChange with a flag notify-references-on-change . Fix completion not working when reader macro on file - Fixes #332 2021.02.19-23.08.40 # Fix duplicated symbols for cljc files on textDocument/documentSymbols - Fixes #328 Add namespace require when completing a unimported namespace - Fixes #309 Fix completion not working for cljc files 2021.02.19-00.19.27 # Fix completion of invalid clojure core (e.g. foo/ ) - Fixes #270 2021.02.17-17.00.45 # Allow find all references across the project of simple keywords Allow specify custom sqlite.db location with sqlite-db-path , default to <project>/.lsp/sqlite.db 2021.02.14-19.46.47 # Removing false positive logs from invalid analysis from clj-kondo macro expand analysis Fix call hierarchy when the reference was not open yet in the editor. Smart re-analyze variable/function references when arguments of the definition were updated. Rollback Macos native image compress until it works for MacOS Big Sur - #322 2021.02.13-18.04.19 # Bump clj-kondo to fix false-positive unresolved-vars Prioritize project analysis on all analysis during find definition - Fixes #318 Compress native binaries with UPX decreasing binary size. 2021.02.12-03.13.12 # Fix completion issues with graalvm native linux binaries when completing local variables. Fix completion exception when completing numbers - Fixes #310 Completion inside a require suggests all available namespaces Change log pattern to /tmp/clojure-lsp.<TIMESTAMP>.out use default temp file. Should fix issues with permissions on tmp folder. 2021.02.11-12.43.06 # Fix auto add ns not working for projects. New code action: Move to let New code action: Change coll to map, list, set or vector 2021.02.10-03.01.19 # Fix config passed to clj-kondo during analysis - Fixes #308 2021.02.09-18.28.06 # Fix auto add ns to check project root and source paths Add alias on copmletion items - Fix completion items for Calva client 2021.02.07-22.51.26 # Fix install-latest-clojure-lsp.sh script - #304 Fix clojure-lsp re-analysing classpath when project contains a keyword starting with a number - #305 Allow clj-kondo to pick up config correctly in mono repos - #303 2021.02.07-03.04.31 # Make release's native binaries executable by default - #299 Improve completion removing the necessity to call completion/resolveItem - #292 New code action: Add suggested alias to namespaces - #302 2021.02.05-03.05.34 # Add support for keyword analysis (definition, references, completion, rename, hover) Reduce jar and binaries size excluding some dependencies (Need to fix a lein issue yet) 2021.02.04-02.08.58 # Fix --version on graalvm native compiled binaries 2021.02.04-01.09.21 # Add integration tests to release process 2021.02.02-14.02.23 # Fix clojure-lsp embedded jar binary during release CI Fix duplicate references on cljc files 2021.02.02-03.06.46 # Add clojure.java.io to known requires - #291 Add manual System/gc after first classpath scan, it should decrease memory after the first startup Add support for Windows GraalVM compiled native binary 2021.02.01-20.37.52 # Add native binaries for Linux and MacOS compiled with GraalVM #267 (Experimental) 2021.01.28-03.03.16 # Fix clj-kondo batch analysis when merging batchs - Fix #284 2021.01.27-21.47.42 # Fix missing printlng and avoid errors for next time (this was causing issues in clients like vim coc) 2021.01.26-22.35.27 # Fix document-symbol after #261 - Fixes #276 Reduce memory usage on startup batch analyzing classpath via clj-kondo. - Fixes #268 2021.01.25-22.56.05 # Do not remove document on textDocument/didClose , related to #264. Fix default project-specs for shadow-cljs to use npx prefix. Fix range of textDocument/hover for definition usages. Fix completionItem/resolve broken after #261. 2021.01.25-17.22.05 # Remove references code-lens from deftest forms Fix completion for alias ns from external deps - Fixes #269 2021.01.22-13.04.28 # Huge refactor https://github.com/clojure-lsp/clojure-lsp/pull/261 which uses clj-kondo analysis / findings output to almost all clojure-lsp features. Should significantly increase performance and startup time Should fix almost all bugs/issues with windows Users since we now rely on clj-kondo analysis Remove all lint configs from clojure-lsp including macro-defs , they should be configured on clj-kondo side now via .clj-kondo/config.edn Move file path on documentation to bottom 2021.01.20-01.39.32 # Fixes args for extract-function refactoring - Fixes #263 2021.01.16-03.28.20 # Check for defintions when finding references with includeDeclaration as true - Fixes #260 Add custom command cursor-info to debugging clojure-lsp. Fix unnecessary new-lines on imports when executing clean-ns 2021.01.14-23.15.54 # Check for the whole line to add-miising-* code actions instead of expect the cursor at the ns to be required/imported - Fixes #258 Return all possible add-missing-* code actions to the same line. 2021.01.14-17.19.10 # Fix add missing import code actions after refactor 2021.01.14-12.44.42 # Fixes #208 2021.01.14-02.30.28 # LSP 3.16: Add support for codeAction/resolve improving performance if client supports it Bump extend lib [CI] Remove auto release, next releases should contain more than one PR/fix","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#unreleased","text":"General Bump Graalvm from 21.2.0 to 21.3.0 improving binary performance/size Fix wrong parse of code when code contains namespaced maps like #:foo{:bar 1} . This issue was affecting a lot of features for example code actions. Bump datalevin from 0.5.26 to 0.5.27. Improve semantic tokens for dynamic vars, function definitions, namespaced and aliased keywords. Fix bug where :source-paths settings could be hot-reloaded with wrong-value. Add support for window/showDocument LSP method, used on create-test command/code action after creating the test to show the test file. Editor Deprecates setting :show-docs-arity-on-same-line? in favor of :hover :arity-on-same-line? . Add support to new LSP LinkedEditingRange feature. #341 Improve suggested Add require ... code actions, this should make clojure-lsp smarter when user wants to add a missing require. #614 Change :notify-references-on-file-change default from false to true , we had some performance improvements and I've been testing this for some time now and didn't see any new issues with that. This should improve a lot the UX when user change any code that is references on other files, updating the diagnostics for those files as well. Improve rename feature UX to output errors when it's not possible rename. Add new Unwind thread once and Unwind whole thread code actions to undo a thread call. Improve code actions performance request async all actions.","title":"Unreleased"},{"location":"CHANGELOG/#20211020-164947","text":"Editor Hot fix clojuredocs on graalvm native image. Bump clj-kondo to 2021.10.20-20211020.123254-3 to fix a specific issue with cljs. Implement support to return to client LSP Errors, making user UX better since clojure-lsp can return specific errors for specific exceptions.","title":"2021.10.20-16.49.47"},{"location":"CHANGELOG/#20211020-130411","text":"General Improve intialization feedback report messages. Consider dev and test alias for deps.edn projects as project-specs during classpath lookup. #586 Avoid scanning source-paths twice, as it was being considered as part of external classpath as well. Change cache db from sqlite to datalevin for faster startup + better graalvm compatibility. Make the cache analysis save async to make startup faster. Support Auto refresh settings memoizing with a ttl of 1 second avoiding the need of restarting server when changing configs. #502 Bump clj-kondo adding new gen-class linter and other fixes/improvements. Fixes #589 Remove unused duplicate require if any. #527 Fix crash on clean-ns when ns contains comments. Improve project analysis filter to check source-paths. #597 Editor Add reference code lens for ns forms. #578 Fix expand-let bug that occurs when a list form precedes let. #590 Add new command to create test for function at point. #582 Add new code action to create test for current function/var Add private to documentSymbol to make clear that a var or function is private . Add new code action Suppress xxx diagnostic , adding clj-kondo comment code to ignore the diagnostic. #591 Add more semantic tokens: aliases for macros, variable and function definitions. Add clojuredocs information during symbol hover. #571 This release was supported by Clojurists Together","title":"2021.10.20-13.04.11"},{"location":"CHANGELOG/#20210930-152801","text":"Editor Hot fix hover content wrong type hinting.","title":"2021.09.30-15.28.01"},{"location":"CHANGELOG/#20210930-122816","text":"General Use lower-case for refer/import/require sorting. #560 #561 Avoid removing comments when sorting/cleaning namespace. #559 Break lines when sorting refers along with then new :clean :sort :refer :max-line-length setting with a default of 80 . #562 Deprecate lens-segregate-test-references in favor to :code-lens :segregate-test-references Check for a default .cljfmt.edn config file for cljfmt config settings if no :cljfmt-config-path was provided. #563 Bump clj-kondo to 2021.09.25 fixing false-positives with potemkin import-var analysis. Re-scan whole project if any clj-kondo config changed for better consistence. #331 Fix clojure-lsp not initializing when empty project.clj . #579 Support finding config in classpath via new setting :classpath-config-paths [\"my-org/my-lib\"] . #580 Editor Fix resolve macro as code action after regression introduced recently. Fix unused-public-var not being suppressed during project startup. #554 Improve hover feature to return elements when inside a function call. #569 Fix create-private-function command and code action to consider when new function is inside thread macros. Support $/progress LSP feature, sending notifications for client when server is starting, improving the feedback for the user. Improve semantic tokens support for java classes and methods. API/CLI Support renaming namespaces as well with rename feature. Use relative paths instead of absolute paths on diff messages. Add analyze-project! to analyze whole project only and cache analysis, useful for REPL usage for example. Follow same exit status from clj-kondo for diagnostics feature. #572 Improve start project feedback reporting the percentage and specific message. This release was supported by Clojurists Together","title":"2021.09.30-12.28.16"},{"location":"CHANGELOG/#20210913-222535","text":"Editor Rollback change on didChangeWatchedFiles for :change events, avoiding outdated changes overwriting newer changes.","title":"2021.09.13-22.25.35"},{"location":"CHANGELOG/#20210913-193200","text":"General Create .clj-kondo folder if not exists in project root. #528 Fix exception when :clojure-lsp/unused-public-var linter is :off . #546 Bump clj-kondo to 2021.08.07-20210903.210340-28 to fix a false-positive with potemkin. https://github.com/clj-kondo/clj-kondo/issues/1370. Bump clj-kondo to 2021.08.07-20210909.131804-29 fixing issues with built-in clj-kondo cache not present on graalvm binaries. #548 Exclude cljs.test/deftest from unused public vars linter. Migrate default db file from .lsp/sqlite.db to .lsp/.cache/sqlite.db , this is necessary as in the future we will replace sqlite with other db implementation, for users they just need to consider/gitignore the .lsp/.cache folder, this way any next change on db implementations or any other cache will not affect user. Auto migrate existing .lsp/sqlite.db to new .lsp/.cache/sqlite.db to avoid unnecessary project re-scan. Deprecates :sqlite-db-path in place of :cache-path . Editor Fix didChangeWatchedFiles to correctly create the file on server, properly change file content and re-scan with clj-kondo, or remove file analysis. This should improve LSP analysis reliability when changing files outside the editor. #536 Improve completion only showing valid local vars for current cursor. Improve completion sorting adding priority to each item, showing most used symbols like variables and functions first before other completion items. API/CLI New diagnostics command, which return all diagnostics found by clojure-lsp (using clj-kondo). Check the API section for more details. This release was supported by Clojurists Together","title":"2021.09.13-19.32.00"},{"location":"CHANGELOG/#20210904-171144","text":"Hotfix java classes not present on jar, required for clojure-lsp downstreams.","title":"2021.09.04-17.11.44"},{"location":"CHANGELOG/#20210903-004246","text":"General Improve logging during startup for better troubleshooting. Refactor allowing calls to clojure-lsp.main/run! for manually passing args, useful for lein-clojure-lsp for example. Internal: Move graalvm configuration to sqlite-jdbc. Recognize deftest as function definition form for refactoring features like extract-function . Bump Graalvm from 21.1.0 to 21.2.0 API/CLI Use clj-kondo custom lint for API as well, required for correct diagnostics API feature. Editor Fix regression, custom source-paths from initializationOptions were not being parsed correctly. #537 Documentation New domain for documentation and webpage https://clojure-lsp.io","title":"2021.09.03-00.42.46"},{"location":"CHANGELOG/#20210824-144156","text":"General Fix classpath scan when classpath has other things like new lines or warning message besides the classpath. Fixes #523 Improve clean-ns to remove empty reader conditionals( #?(:clj) or #?@(:clj []) on ns form) after cleaning requires/imports. Fix clean-ns false-positives removals to cljc files when the alias/refer/import is being used inside a reader conditional. Add new setting :linters :clj-kondo :ns-exclude-regex which allows exclude diagnostics/findings for namespaces matching that regex. Fix merge of configs resolved for projects with multiple configurations in parent folders and subprojects. Docs Improved the settings docs with a new link to a file with all available clojure-lsp settings.","title":"2021.08.24-14.41.56"},{"location":"CHANGELOG/#20210816-190230","text":"Fix clojure-lsp --version","title":"2021.08.16-19.02.30"},{"location":"CHANGELOG/#20210816-144754","text":"General Fix wrong parse of source-paths for bb.edn when :paths contains symbols not only strings. #507 Bump clj-kondo to fix a issue with clojure-lsp running in a lein process. Editor Fix find-definition in jars for cljc files where the var is available on both cljs and clj files. #509 Add clojure.core.async common vars to common-refers to be required via code action. Remove diagnostics when files are deleted, properly cleaning server. #513 Don't add ns form to blank edn files. #515 Fix initializationOptions parsing for some clients. #516 Fix refactor 'add missing refer' when there is already that namespace with a alias but no refers. Improve :notify-references-on-file-change performance and use-cases, still disabled by default for some time. API Rollback printing only via CLI to work with API as well. (can be disabled via :raw? option) Support for release of lein-clojure-lsp","title":"2021.08.16-14.47.54"},{"location":"CHANGELOG/#20210805-193609","text":"Bump clj-kondo to fix window path issues with analysis. Fix issue with references code lens for vim.","title":"2021.08.05-19.36.09"},{"location":"CHANGELOG/#20210805-182554","text":"Fix async project lint after startup for huge projects. #506 Fix :lint-project-files-after-startup? to be considered before clojure-lsp lint unusued public vars. Fix excluded symbols for code lens, making clojure-lsp check clj-kondo config as well for the :clojure-lsp/unused-public-var excludes","title":"2021.08.05-18.25.54"},{"location":"CHANGELOG/#20210803-133303","text":"General Parse correctly unescaped URIs sent from clients like vim avoiding errors on some features. Bump clj-kondo fixing analysis position issue with declare , making rename and other features work. Don't use PowerShell profiles on Windows when analyzing classpath. Fixes https://github.com/BetterThanTomorrow/calva/issues/1050 Support babashka classpath and source-paths discovery via bb.edn file. (needs babashka >= 0.5.1) Editor Add :hover :hide-file-location? settings option to disable displaying the source path on hover. Use new clj-kondo :custom-lint-fn for the :unused-public-var , this should improve performance and give the ability to suppress unused vars via code with #_{:clj-kondo/ignore [:clojure-lsp/unused-public-var]} or #_:clj-kondo/ignore","title":"2021.08.03-13.33.03"},{"location":"CHANGELOG/#20210728-142406","text":"General Minor fix on the analysis queries comparison. Improve GraalVM configuration to use direct/less configurations. Bump clj-kondo 2021.06.18 -> 2021.07.28 which adds support for macroexpanding. Editor Fix outgoing/incoming call hierarchy when vars are outside project/external jars. Fix completion of aliases without var names typed yet, for example: string/ API/CLI Fix filename in diffs with dry option. Add coloring to diffs following git diff. Add ns-exclude-regex for commands that check whole project, allowing to exclude certain namespaces via regex.","title":"2021.07.28-14.24.06"},{"location":"CHANGELOG/#20210719-144652","text":"General clean-ns now sorts ns children forms according to the ClojureStyleGuide, at the moment moving require form before import form, enabled by default under flag :clean :sort :ns setting. Improve startup error handler and logging during project analysis. Related to #484 Performance improvements using transducers on analysis queries. Fixed auto-resolve source-paths for lein projects that get source-paths dynamically, clojure-lsp will use the default source-paths for these cases Editor Improve hover output, both markdown and plain text forms. Allow calling thread-first/last and thread-first-all/last-all from within the list. Improve resolve-macro-as messages and default excluded symbols. API/CLI Fix empty XDG_CONFIG_HOME not defaulting to $HOME/.config #474 Improve verbose logging setting.","title":"2021.07.19-14.46.52"},{"location":"CHANGELOG/#20210712-123059","text":"Editor Make semantic-tokens return no token for unknown symbols which has :clj-kondo/unknown-namespace on its analysis. Fix file uri location when hovering a symbol. Add reference code lens to keyword definitions, e.g. re-frame.core/reg-sub . Add semantic-tokens debug information to cursor-info response. API/CLI Fix when ns form does not match filename. #466 Fix errors with project-root on graalvm binary Improve API usage avoiding exceptions and returning just data instead. Improve analysis cache to multiple API calls. Add new --raw option allowing to display only raw data. Useful to integrate with other tools like reviewdog.","title":"2021.07.12-12.30.59"},{"location":"CHANGELOG/#20210705-203112","text":"API/CLI Add --verbose option for debugging purposes. Fix usage as library parsing :exec-args correctly","title":"2021.07.05-20.31.12"},{"location":"CHANGELOG/#20210705-151214","text":"General Add :clean :sort settings option to disable sorting during clean-ns . Add :keep value to :ns-indent-blocks-indentation setting to don't change indentation during clean-ns . Deprecate install-latest-clojure-lsp.sh in place of install new script. Improve source paths discoverability for leiningen projects following the same rules as deps.edn projects. For more information, check the settings section . API/CLI Add --dry option to commands, useful to print only diffs instead of making changes. Check the new setup-clojure-lsp Github Action to run clojure-lsp on CI. Add format feature using cljfmt. Now, every release is available in clojars as com.github.clojure-lsp/clojure-lsp .","title":"2021.07.05-15.12.14"},{"location":"CHANGELOG/#20210701-194902","text":"Fix --project-path option for API. Add --log-path option to API.","title":"2021.07.01-19.49.02"},{"location":"CHANGELOG/#20210701-134618","text":"Fix find-references and references lens for defrecord . Improve clean-ns refactoring following the Clojure style guide. Fix clean-ns corner case issue where it would replace the :as value with the :refer value. Deprecate :keep-require-at-start? in favor of :clean :ns-inner-blocks-indentation with default value of :next-line . Bump org.xerial/sqlite-jdbc from 3.34.0 to 3.36.0. Avoid adding duplicated namespace for new blank files. Add API / CLI support, form more information check the API section.","title":"2021.07.01-13.46.18"},{"location":"CHANGELOG/#20210624-142411","text":"Fix missing LSP 3.16 graalvm reflection configs. #452","title":"2021.06.24-14.24.11"},{"location":"CHANGELOG/#20210624-012001","text":"Fix graalvm reflect config for LSP 3.16 protocol. #449 Use last definition when showing signature help. #446 Create 2 new LSP custom methods: clojure/serverInfo/raw and clojure/serverInfo/log deprecating old commands server-info and cursor-info , check the documentation for more information. Add :final-settings to serverInfo methods. #450","title":"2021.06.24-01.20.01"},{"location":"CHANGELOG/#20210621-143054","text":"Avoid removing whole require if unused refer but with used alias during clean-ns. #447 Bump cljfmt 0.7.0 -> 0.8.0. Fixes #266 Bump clj-kondo 2021.06.01 -> 2021.06.18","title":"2021.06.21-14.30.54"},{"location":"CHANGELOG/#20210614-170047","text":"Improve source paths discoverability for deps.edn projects. Adds :source-aliases for customization. For more information, check the settings section .","title":"2021.06.14-17.00.47"},{"location":"CHANGELOG/#20210601-161944","text":"Fix graalvm issue on completionItem InsertTextMode Bump clj-kondo and rewrite-clj to latest releases.","title":"2021.06.01-16.19.44"},{"location":"CHANGELOG/#20210527-174234","text":"Fix corner case error with project paths with spaces or other special characters. #437 Drastically improve didOpen performance, improving kondo findings parsing and making linting async avoiding blocking some editors. #435 Fix :auto-add-ns-to-new-files? flag always being considered as true . #436","title":"2021.05.27-17.42.34"},{"location":"CHANGELOG/#20210522-165045","text":"Fix completion item kind of clojure core items. Fixes #426 Fix graalvm reflect config for SublimeText - #430 Improve code lens for segregated code lens when on test files.","title":"2021.05.22-16.50.45"},{"location":"CHANGELOG/#20210514-152602","text":"Include non full qualified vars on unused-public-var exclude filter. Improve hover documentation: use correct markdown for docstrings; remove unnecessary new lines; add link to filename location. Rollback full text changes on last release and change approach for a temporary fix. #424","title":"2021.05.14-15.26.02"},{"location":"CHANGELOG/#20210506-194400","text":"Quick fix full text changes to handle it sync for semantic tokens Segregate main references from test references with option to disable via lens-segregate-test-references","title":"2021.05.06-19.44.00"},{"location":"CHANGELOG/#20210427-201745","text":"Significantly improve the performance of workspace symbol filtering/searching. See relevant commit . Always sort refers when clean-ns. Add support for installing with homebrew on Linux. Bump clj-kondo to 2021.04.24-20210426.144134-2 adding support for finding re-frame by keyword. Fixes #411 Fix find definition going to declare - Fixes #340 Remove common already known clojure macros from Resolve macro as code action.","title":"2021.04.27-20.17.45"},{"location":"CHANGELOG/#20210423-154947","text":"Improve resolve-macro-as command to check and log if couldn't resolve the macro. Improve workspace symbol filtering/searching. Now, the sole candidates shown are guaranteed to include all the characters contained in the filter/search string. Add more tokens to semantic tokens: keywords, functions/var usages, java classes, local variables. Bump Graalvm from 21.0.0 to 21.1.0 Bump clj-kondo to 2021.04.23 fixing some keywords corner cases.","title":"2021.04.23-15.49.47"},{"location":"CHANGELOG/#20210413-124733","text":"Add common snippets on completion. Check all available snippets here . Add support for custom snippets via :additional-snippets . Check here for more information. - Fixes #403 Bump lsp4j from 0.11.0 -> 0.12.0","title":"2021.04.13-12.47.33"},{"location":"CHANGELOG/#20210407-163410","text":"Fix renaming keywords in cljc files producing duplicate edits. After project startup, publish all project only diagnostics. This is a approach done by other LSPs to make work features like Project errors . Feature flag via lint-project-files-after-startup? with default true . Add experimental support for aarch64 linux native binary Fix formatting issues with a regression introduced on a previous release. - Fixes #339 and #396","title":"2021.04.07-16.34.10"},{"location":"CHANGELOG/#20210403-184355","text":"Fix textDocument/workspaceSymbols filter not working on native binaries. Report duplicate linters as default, can be disabled via :linters :clj-kondo :report-duplicates - Fixes #390 Bump rewrite-clj to 1.0.605-alpha to fix exceptions when on clojure files with babashka interpreter on first line. Bump clj-kondo 2021.04.01-20210402.215253-6 to fix bug https://github.com/clj-kondo/clj-kondo/issues/1246","title":"2021.04.03-18.43.55"},{"location":"CHANGELOG/#20210330-204234","text":"Bump clj-londo 2021.03.22-20210327.192113-4 - Fixes #385 Add support for outgoing call hierarchy - Fixes #384 Improve and fix missing completion item kinds.","title":"2021.03.30-20.42.34"},{"location":"CHANGELOG/#20210326-234107","text":"Bump clj-kondo 2021.03.22-20210324.110254-3 - Fixes #382 [graalvm] Fixes Unable to invoke no-args constructor for class org.eclipse.lsp4j.ShowDocumentCapabilities error. Fix/enhance keyword rename - #383","title":"2021.03.26-23.41.07"},{"location":"CHANGELOG/#20210324-004155","text":"Migrate from lein to deps.edn Bump clj-kondo to 2021.03.22 Fix clean-ns sorting according to symbols not brackets - Fixes #380 Fix missing graalvm reflect config for CompletionItemTextEdit - Fixes #381","title":"2021.03.24-00.41.55"},{"location":"CHANGELOG/#20210321-232919","text":"Add code action 'resolve macro as', it requires client to fill the chosen macro and clj-kondo config file. Bump rewrite-clj to 1.0.594-alpha Bump data.json to 2.0.1 Bump lsp4j to 0.11.0","title":"2021.03.21-23.29.19"},{"location":"CHANGELOG/#20210318-192341","text":"Add support for diagnostic tags: deprecated and unnecessary. Fix wrong textDocument/documentHighlight for function local-usages. Use new clj-kondo copy-configs flag to copy hooks during lint. Bunp clj-kondo to fix unused public linter check for :exclude-when-defined-by","title":"2021.03.18-19.23.41"},{"location":"CHANGELOG/#20210316-202806","text":"Fix server not analyzing after a wrong code on cljs files - #367 Rollback incremental didChange adding a new :text-document-sync-kind setting with :full as default.","title":"2021.03.16-20.28.06"},{"location":"CHANGELOG/#20210314-232246","text":"Fix completion inside refers, re-add support for it - Fixes #364 Change range of expression functions clj-kondo diagnostics to avoid collision with function signature.","title":"2021.03.14-23.22.46"},{"location":"CHANGELOG/#20210306-170535","text":"Fix incremental didChange, debouncing distincting by uri, fixing some inconsistent file changes when multiple files are changed at same time (rename, iedit, etc). Make unused-public-var ignore -main public functions. Add :exclude-when-defined-by option to unused-public-var linter, check settings documentation for more information.","title":"2021.03.06-17.05.35"},{"location":"CHANGELOG/#20210305-133547","text":"Fix clojure-lsp lint crash when analyzing specific macros with clj-kondo hooks. Fix didChange for Nvim client. Add new clojure-lsp linter: unused-public-var - Fixes #359 Add option to disable clj-kondo linter, check settings documentation for more details.","title":"2021.03.05-13.35.47"},{"location":"CHANGELOG/#20210301-191854","text":"Bump clj-kondo fixing issues on require form not being analyzed. Fix textDocument/workspaceSymbols to use the query sent by client.","title":"2021.03.01-19.18.54"},{"location":"CHANGELOG/#20210227-233555","text":"Add support to complete full qualified namespaces - Fixes #337 Add :log-path setting to log to a custom file. Avoid exception on code actions when on cljc reader macros - Related to #346","title":"2021.02.27-23.35.55"},{"location":"CHANGELOG/#20210226-135848","text":"Improve clojure-lsp config search checking always home dir considering XDG_CONFIG_HOME and project root up to system root (/) - Fixes #339. Handle incremental text changes on textDocument/didChange notifications following LSP protocol, improving performance for huge files. Add clj-kondo version to --version and server-info. Add new create private function code action.","title":"2021.02.26-13.58.48"},{"location":"CHANGELOG/#20210224-142308","text":"Improve completion performance resolving the item only when documentation is requested Add new thread first/last all code actions","title":"2021.02.24-14.23.08"},{"location":"CHANGELOG/#20210221-210251","text":"Implement support for textDocument/signatureHelp - Fixes #324 Disable notify-references on didChange with a flag notify-references-on-change . Fix completion not working when reader macro on file - Fixes #332","title":"2021.02.21-21.02.51"},{"location":"CHANGELOG/#20210219-230840","text":"Fix duplicated symbols for cljc files on textDocument/documentSymbols - Fixes #328 Add namespace require when completing a unimported namespace - Fixes #309 Fix completion not working for cljc files","title":"2021.02.19-23.08.40"},{"location":"CHANGELOG/#20210219-001927","text":"Fix completion of invalid clojure core (e.g. foo/ ) - Fixes #270","title":"2021.02.19-00.19.27"},{"location":"CHANGELOG/#20210217-170045","text":"Allow find all references across the project of simple keywords Allow specify custom sqlite.db location with sqlite-db-path , default to <project>/.lsp/sqlite.db","title":"2021.02.17-17.00.45"},{"location":"CHANGELOG/#20210214-194647","text":"Removing false positive logs from invalid analysis from clj-kondo macro expand analysis Fix call hierarchy when the reference was not open yet in the editor. Smart re-analyze variable/function references when arguments of the definition were updated. Rollback Macos native image compress until it works for MacOS Big Sur - #322","title":"2021.02.14-19.46.47"},{"location":"CHANGELOG/#20210213-180419","text":"Bump clj-kondo to fix false-positive unresolved-vars Prioritize project analysis on all analysis during find definition - Fixes #318 Compress native binaries with UPX decreasing binary size.","title":"2021.02.13-18.04.19"},{"location":"CHANGELOG/#20210212-031312","text":"Fix completion issues with graalvm native linux binaries when completing local variables. Fix completion exception when completing numbers - Fixes #310 Completion inside a require suggests all available namespaces Change log pattern to /tmp/clojure-lsp.<TIMESTAMP>.out use default temp file. Should fix issues with permissions on tmp folder.","title":"2021.02.12-03.13.12"},{"location":"CHANGELOG/#20210211-124306","text":"Fix auto add ns not working for projects. New code action: Move to let New code action: Change coll to map, list, set or vector","title":"2021.02.11-12.43.06"},{"location":"CHANGELOG/#20210210-030119","text":"Fix config passed to clj-kondo during analysis - Fixes #308","title":"2021.02.10-03.01.19"},{"location":"CHANGELOG/#20210209-182806","text":"Fix auto add ns to check project root and source paths Add alias on copmletion items - Fix completion items for Calva client","title":"2021.02.09-18.28.06"},{"location":"CHANGELOG/#20210207-225126","text":"Fix install-latest-clojure-lsp.sh script - #304 Fix clojure-lsp re-analysing classpath when project contains a keyword starting with a number - #305 Allow clj-kondo to pick up config correctly in mono repos - #303","title":"2021.02.07-22.51.26"},{"location":"CHANGELOG/#20210207-030431","text":"Make release's native binaries executable by default - #299 Improve completion removing the necessity to call completion/resolveItem - #292 New code action: Add suggested alias to namespaces - #302","title":"2021.02.07-03.04.31"},{"location":"CHANGELOG/#20210205-030534","text":"Add support for keyword analysis (definition, references, completion, rename, hover) Reduce jar and binaries size excluding some dependencies (Need to fix a lein issue yet)","title":"2021.02.05-03.05.34"},{"location":"CHANGELOG/#20210204-020858","text":"Fix --version on graalvm native compiled binaries","title":"2021.02.04-02.08.58"},{"location":"CHANGELOG/#20210204-010921","text":"Add integration tests to release process","title":"2021.02.04-01.09.21"},{"location":"CHANGELOG/#20210202-140223","text":"Fix clojure-lsp embedded jar binary during release CI Fix duplicate references on cljc files","title":"2021.02.02-14.02.23"},{"location":"CHANGELOG/#20210202-030646","text":"Add clojure.java.io to known requires - #291 Add manual System/gc after first classpath scan, it should decrease memory after the first startup Add support for Windows GraalVM compiled native binary","title":"2021.02.02-03.06.46"},{"location":"CHANGELOG/#20210201-203752","text":"Add native binaries for Linux and MacOS compiled with GraalVM #267 (Experimental)","title":"2021.02.01-20.37.52"},{"location":"CHANGELOG/#20210128-030316","text":"Fix clj-kondo batch analysis when merging batchs - Fix #284","title":"2021.01.28-03.03.16"},{"location":"CHANGELOG/#20210127-214742","text":"Fix missing printlng and avoid errors for next time (this was causing issues in clients like vim coc)","title":"2021.01.27-21.47.42"},{"location":"CHANGELOG/#20210126-223527","text":"Fix document-symbol after #261 - Fixes #276 Reduce memory usage on startup batch analyzing classpath via clj-kondo. - Fixes #268","title":"2021.01.26-22.35.27"},{"location":"CHANGELOG/#20210125-225605","text":"Do not remove document on textDocument/didClose , related to #264. Fix default project-specs for shadow-cljs to use npx prefix. Fix range of textDocument/hover for definition usages. Fix completionItem/resolve broken after #261.","title":"2021.01.25-22.56.05"},{"location":"CHANGELOG/#20210125-172205","text":"Remove references code-lens from deftest forms Fix completion for alias ns from external deps - Fixes #269","title":"2021.01.25-17.22.05"},{"location":"CHANGELOG/#20210122-130428","text":"Huge refactor https://github.com/clojure-lsp/clojure-lsp/pull/261 which uses clj-kondo analysis / findings output to almost all clojure-lsp features. Should significantly increase performance and startup time Should fix almost all bugs/issues with windows Users since we now rely on clj-kondo analysis Remove all lint configs from clojure-lsp including macro-defs , they should be configured on clj-kondo side now via .clj-kondo/config.edn Move file path on documentation to bottom","title":"2021.01.22-13.04.28"},{"location":"CHANGELOG/#20210120-013932","text":"Fixes args for extract-function refactoring - Fixes #263","title":"2021.01.20-01.39.32"},{"location":"CHANGELOG/#20210116-032820","text":"Check for defintions when finding references with includeDeclaration as true - Fixes #260 Add custom command cursor-info to debugging clojure-lsp. Fix unnecessary new-lines on imports when executing clean-ns","title":"2021.01.16-03.28.20"},{"location":"CHANGELOG/#20210114-231554","text":"Check for the whole line to add-miising-* code actions instead of expect the cursor at the ns to be required/imported - Fixes #258 Return all possible add-missing-* code actions to the same line.","title":"2021.01.14-23.15.54"},{"location":"CHANGELOG/#20210114-171910","text":"Fix add missing import code actions after refactor","title":"2021.01.14-17.19.10"},{"location":"CHANGELOG/#20210114-124442","text":"Fixes #208","title":"2021.01.14-12.44.42"},{"location":"CHANGELOG/#20210114-023028","text":"LSP 3.16: Add support for codeAction/resolve improving performance if client supports it Bump extend lib [CI] Remove auto release, next releases should contain more than one PR/fix","title":"2021.01.14-02.30.28"},{"location":"api/","text":"API # clojure-lsp is commonly used in a text editor, but it has its own API featuring the main features that can be used as a library or via CLI. This is a new feature and it's experimental, so things can break at any moment, so please open an issue if find anything wrong. Usages # CLI # clojure-lsp --help should show all available commands and options. Library # The namespace clojure-lsp.api should be used as the entrypoint for the same available features of the CLI, feel free to open a issue for missing features. Below is an example using the clean-ns feature on a deps.edn project: { :aliases { :lint-ns { :replace-deps { com.github.clojure-lsp/clojure-lsp { :mvn/version \"...\" }} :exec-fn clojure-lsp.api/clean-ns! :exec-args { :dry? true }}}} CI # You can use setup-clojure-lsp GitHub action to install clojure-lsp in a CI. Remember to install your build tool, like clojure or leiningen as well in your CI according to your project to clojure-lsp be able to scan the classpath correctly. Leiningen # To run clojure-lsp from leiningen easily, check lein-clojure-lsp plugin. Usage # clean-ns Useful for cleaning the namespaces forms of your project, removing any unused required, import or refer, sorting and indenting correctly. format Useful for formatting the namespaces of your project, using cljfmt and following the rules from the :cljfmt clojure-lsp setting. diagnostics Bring all diagnostics/lint found by clojure-lsp (using clj-kondo under the hood). rename Rename a symbol and all its references across the project. Settings # clojure-lsp will check for .lsp/config.edn in the project or home dir, but it's possible to force override the settings via the :settings option of the API or --settings option of the CLI. For all available settings, check the settings section documentation .","title":"API"},{"location":"api/#api","text":"clojure-lsp is commonly used in a text editor, but it has its own API featuring the main features that can be used as a library or via CLI. This is a new feature and it's experimental, so things can break at any moment, so please open an issue if find anything wrong.","title":"API"},{"location":"api/#usages","text":"","title":"Usages"},{"location":"api/#cli","text":"clojure-lsp --help should show all available commands and options.","title":"CLI"},{"location":"api/#library","text":"The namespace clojure-lsp.api should be used as the entrypoint for the same available features of the CLI, feel free to open a issue for missing features. Below is an example using the clean-ns feature on a deps.edn project: { :aliases { :lint-ns { :replace-deps { com.github.clojure-lsp/clojure-lsp { :mvn/version \"...\" }} :exec-fn clojure-lsp.api/clean-ns! :exec-args { :dry? true }}}}","title":"Library"},{"location":"api/#ci","text":"You can use setup-clojure-lsp GitHub action to install clojure-lsp in a CI. Remember to install your build tool, like clojure or leiningen as well in your CI according to your project to clojure-lsp be able to scan the classpath correctly.","title":"CI"},{"location":"api/#leiningen","text":"To run clojure-lsp from leiningen easily, check lein-clojure-lsp plugin.","title":"Leiningen"},{"location":"api/#usage","text":"clean-ns Useful for cleaning the namespaces forms of your project, removing any unused required, import or refer, sorting and indenting correctly. format Useful for formatting the namespaces of your project, using cljfmt and following the rules from the :cljfmt clojure-lsp setting. diagnostics Bring all diagnostics/lint found by clojure-lsp (using clj-kondo under the hood). rename Rename a symbol and all its references across the project.","title":"Usage"},{"location":"api/#settings","text":"clojure-lsp will check for .lsp/config.edn in the project or home dir, but it's possible to force override the settings via the :settings option of the API or --settings option of the CLI. For all available settings, check the settings section documentation .","title":"Settings"},{"location":"building/","text":"Building # GraalVM # Every release, the native binaries (Windows, Linux and MacOS) are compiled with GraalVM and uploaded to Github releases page. To build a native image with GraalVM: Install the GraalVM 21.3.0 for Java 11 and set the GRAALVM_HOME to the installation dir. Install native-image with $GRAALVM_HOME/bin/gu install native-image . Run from clojure-lsp project root ./graalvm/native-unix-compile.sh or ./graalvm/native-windows-compile.bat . The build may take some minutes and the result will be a ./clojure-lsp native binary. Jar # Run clojure -X:prod-jar for building the jar.","title":"Building"},{"location":"building/#building","text":"","title":"Building"},{"location":"building/#graalvm","text":"Every release, the native binaries (Windows, Linux and MacOS) are compiled with GraalVM and uploaded to Github releases page. To build a native image with GraalVM: Install the GraalVM 21.3.0 for Java 11 and set the GRAALVM_HOME to the installation dir. Install native-image with $GRAALVM_HOME/bin/gu install native-image . Run from clojure-lsp project root ./graalvm/native-unix-compile.sh or ./graalvm/native-windows-compile.bat . The build may take some minutes and the result will be a ./clojure-lsp native binary.","title":"GraalVM"},{"location":"building/#jar","text":"Run clojure -X:prod-jar for building the jar.","title":"Jar"},{"location":"capabilities/","text":"Capabilities # Implementation Status # Below are all the currently supported LSP capabilities and their implementation status: capability done notes initialize \u221a initialized \u221a shutdown \u221a exit \u221a $/cancelRequest $/progress \u221a window/showDocument \u221a window/showMessage \u221a window/showMessageRequest \u221a window/logMessage window/workDoneProgress/create window/workDoneProgress/cancel telemetry/event client/registerCapability \u221a client/unregisterCapability workspace/workspaceFolders workspace/didChangeWorkspaceFolders workspace/didChangeConfiguration \u221a Currently does nothing but log workspace/configuration workspace/didChangeWatchedFiles \u221a workspace/symbol \u221a workspace/executeCommand \u221a See Extra capabilities workspace/applyEdit \u221a TextDocumentEdit and RenameFile only textDocument/didOpen \u221a textDocument/didChange \u221a textDocument/willSave textDocument/willSaveWaitUntil textDocument/didSave \u221a Do nothing currently textDocument/didClose \u221a textDocument/publishDiagnostics \u221a textDocument/completion \u221a completionItem/resolve \u221a textDocument/hover \u221a textDocument/signatureHelp \u221a Missing support for active parameter ATM textDocument/declaration textDocument/definition \u221a TODO: Find java classes definition textDocument/typeDefinition textDocument/implementation textDocument/references \u221a textDocument/documentHighlight \u221a textDocument/documentSymbol \u221a textDocument/codeAction \u221a codeAction/resolve \u221a textDocument/codeLens \u221a codeLens/resolve \u221a textDocument/documentLink documentLink/resolve textDocument/documentColor textDocument/colorPresentation textDocument/formatting \u221a textDocument/rangeFormatting \u221a textDocument/onTypeFormatting textDocument/rename \u221a textDocument/prepareRename textDocument/foldingRange textDocument/selectionRange textDocument/semanticTokens/full \u221a textDocument/semanticTokens/full/delta textDocument/semanticTokens/range \u221a workspace/semanticTokens/refresh workspace/codeLens/refresh \u221a textDocument/linkedEditingRange \u221a textDocument/prepareCallHierarchy \u221a callHierarchy/incomingCalls \u221a callHierarchy/outgoingCalls \u221a textDocument/moniker Extra capabilities # Besides LSP official capabilities, clojure-lsp has some extra features: Refactorings # It should be possible to introduce most of the refactorings here More details # Calling executeCommand with the following commands and additional args will notify the client with applyEdit . All commands expect the first three args to be [document-uri, line, column] (eg [\"file:///home/snoe/file.clj\", 13, 11] ) done command args notes \u221a add-import-to-namespace [document-uri, line, column, import-name] \u221a add-missing-libspec \u221a clean-ns \u221a cycle-coll \u221a cycle-privacy \u221a expand-let \u221a extract-function [document-uri, line, column, function-name] \u221a inline-symbol \u221a introduce-let [document-uri, line, column, binding-name] \u221a move-to-let [document-uri, line, column, binding-name] \u221a thread-first \u221a thread-first-all \u221a thread-last \u221a thread-last-all \u221a unwind-all \u221a unwind-thread \u221a resolve-macro-as [document-uri, line, column, resolved-full-symbol kondo-config-path] \u221a create-test See Vim client section for an example. Emacs provides all those refactorings via lsp-mode with the lsp-clojure- prefix. Other clients might provide a higher level interface to workspace/executeCommand you need to pass the path, line and column numbers. Custom methods # clojure-lsp has some custom LSP methods that doesn't follow the protocol but aggregate value as a clojure IDE: command args notes clojure/serverInfo/raw Use to retrieve from server the server configuration information clojure/serverInfo/log Use to log to user the server configuration information clojure/cursorInfo/log [document-uri, line, column] Use to log to user the debugging information for the symbol at cursor","title":"Capabilities"},{"location":"capabilities/#capabilities","text":"","title":"Capabilities"},{"location":"capabilities/#implementation-status","text":"Below are all the currently supported LSP capabilities and their implementation status: capability done notes initialize \u221a initialized \u221a shutdown \u221a exit \u221a $/cancelRequest $/progress \u221a window/showDocument \u221a window/showMessage \u221a window/showMessageRequest \u221a window/logMessage window/workDoneProgress/create window/workDoneProgress/cancel telemetry/event client/registerCapability \u221a client/unregisterCapability workspace/workspaceFolders workspace/didChangeWorkspaceFolders workspace/didChangeConfiguration \u221a Currently does nothing but log workspace/configuration workspace/didChangeWatchedFiles \u221a workspace/symbol \u221a workspace/executeCommand \u221a See Extra capabilities workspace/applyEdit \u221a TextDocumentEdit and RenameFile only textDocument/didOpen \u221a textDocument/didChange \u221a textDocument/willSave textDocument/willSaveWaitUntil textDocument/didSave \u221a Do nothing currently textDocument/didClose \u221a textDocument/publishDiagnostics \u221a textDocument/completion \u221a completionItem/resolve \u221a textDocument/hover \u221a textDocument/signatureHelp \u221a Missing support for active parameter ATM textDocument/declaration textDocument/definition \u221a TODO: Find java classes definition textDocument/typeDefinition textDocument/implementation textDocument/references \u221a textDocument/documentHighlight \u221a textDocument/documentSymbol \u221a textDocument/codeAction \u221a codeAction/resolve \u221a textDocument/codeLens \u221a codeLens/resolve \u221a textDocument/documentLink documentLink/resolve textDocument/documentColor textDocument/colorPresentation textDocument/formatting \u221a textDocument/rangeFormatting \u221a textDocument/onTypeFormatting textDocument/rename \u221a textDocument/prepareRename textDocument/foldingRange textDocument/selectionRange textDocument/semanticTokens/full \u221a textDocument/semanticTokens/full/delta textDocument/semanticTokens/range \u221a workspace/semanticTokens/refresh workspace/codeLens/refresh \u221a textDocument/linkedEditingRange \u221a textDocument/prepareCallHierarchy \u221a callHierarchy/incomingCalls \u221a callHierarchy/outgoingCalls \u221a textDocument/moniker","title":"Implementation Status"},{"location":"capabilities/#extra-capabilities","text":"Besides LSP official capabilities, clojure-lsp has some extra features:","title":"Extra capabilities"},{"location":"capabilities/#refactorings","text":"It should be possible to introduce most of the refactorings here","title":"Refactorings"},{"location":"capabilities/#more-details","text":"Calling executeCommand with the following commands and additional args will notify the client with applyEdit . All commands expect the first three args to be [document-uri, line, column] (eg [\"file:///home/snoe/file.clj\", 13, 11] ) done command args notes \u221a add-import-to-namespace [document-uri, line, column, import-name] \u221a add-missing-libspec \u221a clean-ns \u221a cycle-coll \u221a cycle-privacy \u221a expand-let \u221a extract-function [document-uri, line, column, function-name] \u221a inline-symbol \u221a introduce-let [document-uri, line, column, binding-name] \u221a move-to-let [document-uri, line, column, binding-name] \u221a thread-first \u221a thread-first-all \u221a thread-last \u221a thread-last-all \u221a unwind-all \u221a unwind-thread \u221a resolve-macro-as [document-uri, line, column, resolved-full-symbol kondo-config-path] \u221a create-test See Vim client section for an example. Emacs provides all those refactorings via lsp-mode with the lsp-clojure- prefix. Other clients might provide a higher level interface to workspace/executeCommand you need to pass the path, line and column numbers.","title":"More details"},{"location":"capabilities/#custom-methods","text":"clojure-lsp has some custom LSP methods that doesn't follow the protocol but aggregate value as a clojure IDE: command args notes clojure/serverInfo/raw Use to retrieve from server the server configuration information clojure/serverInfo/log Use to log to user the server configuration information clojure/cursorInfo/log [document-uri, line, column] Use to log to user the debugging information for the symbol at cursor","title":"Custom methods"},{"location":"clients/","text":"Clients # Clients are either editors with built in LSP support like Oni or nvim, or an appropriate plugin. Clients are responsible for launching the server, the server is a subprocess of your editor not a daemon. In general, make sure to configure the client to use stdio and a server launch command like ['/usr/local/bin/clojure-lsp'] . If that fails, you may need to have your client launch inside a shell, so use something like ['bash', '-c', '/usr/local/bin/clojure-lsp'] . In windows you probably need to use the clojure-lsp.bat . TIP : If your editor is not started from the terminal then it is possible that its $PATH is quite different from the one in the shell and clojure-lsp will not be able to find the executables it needs, such as clojure and npx . To alleviate that, create a wrapper script that sets the PATH correctly. Make sure that nothing in the script uses stdin / stdout as these are used for communication with the editor and any extra input/output could mess it up. An example script (also remember to make it executable, e.g. chmod u+x <script> ): #!/bin/bash -l if [ ! -e npx ] ; then export PATH = $PATH :/Users/me/.nvm/versions/node/v10.24.1/bin fi exec /usr/local/bin/clojure-lsp Emacs # lsp-mode has built in support for clojure-lsp . With use-package , add the following to your emacs config: ( use-package lsp-mode :ensure t :hook (( clojure-mode . lsp ) ( clojurec-mode . lsp ) ( clojurescript-mode . lsp )) :config ;; add paths to your local installation of project mgmt tools, like lein ( setenv \"PATH\" ( concat \"/usr/local/bin\" path-separator ( getenv \"PATH\" ))) ( dolist ( m ' ( clojure-mode clojurec-mode clojurescript-mode clojurex-mode )) ( add-to-list 'lsp-language-id-configuration ` ( , m . \"clojure\" ))) ( setq lsp-clojure-server-command ' ( \"/path/to/clojure-lsp\" ))) ;; Optional: In case `clojure-lsp` is not in your $PATH Optionally you can add lsp-ui for UI feedback and company-mode for completion: ( use-package lsp-ui :ensure t :commands lsp-ui-mode ) ( use-package company :ensure t ) In lsp-mode , lsp-clojure-server-command variable is available to override the command to start the clojure-lsp server, might be necessary to do this on a Windows environment. For a detailed guide on how to configure Emacs with LSP, check here For more lsp-mode clojure settings, check here Visual Studio Code # Calva is a extension for VSCode for Clojure Development that includes clojure-lsp. Vim # I prefer https://github.com/neoclide/coc.nvim but both http://github.com/autozimu/LanguageClient-neovim and https://github.com/prabirshrestha/vim-lsp work well. See my nvim/init.vim and coc-settings.json Another example of a Neovim Conjure/CoC/clojure-lsp setup can be found on dharrigan's github repository. LanguageClient-neovim can be configure with: Refactorings: function ! Expand ( exp ) abort let l :result = expand ( a :exp ) return l :result == # '' ? '' : \"file://\" . l :result endfunction nnoremap < silent > crcc : call LanguageClient#workspace_executeCommand ( 'cycle-coll' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crth : call LanguageClient#workspace_executeCommand ( 'thread-first' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtt : call LanguageClient#workspace_executeCommand ( 'thread-last' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtf : call LanguageClient#workspace_executeCommand ( 'thread-first-all' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtl : call LanguageClient#workspace_executeCommand ( 'thread-last-all' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crml : call LanguageClient#workspace_executeCommand ( 'move-to-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 , input ( 'Binding name: ' ) ] )< CR > nnoremap < silent > cril : call LanguageClient#workspace_executeCommand ( 'introduce-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 , input ( 'Binding name: ' ) ] )< CR > nnoremap < silent > crel : call LanguageClient#workspace_executeCommand ( 'expand-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > cram : call LanguageClient#workspace_executeCommand ( 'add-missing-libspec' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > initializationOptions can be sent by setting: let g:LanguageClient_settingsPath=\".lsp/settings.json\" Project-local .lsp/settings.json would have content like: { \"initializationOptions\" : { \"source-paths\" : [ \"shared-src\" , \"src\" , \"test\" , \"dashboard/src\" ] , \"macro-defs\" : { \"project.macros/dofor\" : [ \"bindings\" , \"bound-elements\" ]}}} Further refactoring mappings include being able to invoke the (coc-codeaction-*) function to provide actions such as move to let , change coll to map and so on. nmap <silent> <Leader>cr <Plug>(coc-rename) nmap <silent> <Leader>cf <Plug>(coc-references) xmap <silent> <Leader>c <Plug>(coc-codeaction-selected) nmap <silent> <Leader>c <Plug>(coc-codeaction-line) nmap <silent> gd <Plug>(coc-definition) Nvim # An very detailed document about how configure Nvim as Clojure IDE using fennel, clojure-lsp and conjure. nvim-fennel-lsp-conjure-as-clojure-ide Sublime Text # Clojure LSP can be installed by first installing the LSP plugin which brings Language Server Protocol support to Sublime Text editor and then following the set-up instructions here to download Clojure LSP and how to configure it in Sublime Text. Intellij # Install the LSP Support plugin and configure it to launch clojure-lsp for Clojure/Script files: Go to Preferences / Languages & Frameworks / Language Server Protocol / Server Definitions. Select Raw command . In the Extension field enter clj;cljs;cljc;edn . In the Command field enter the path to the executable, for instance /usr/local/bin/clojure-lsp . BEWARE: The LSP Support plugin has short timeouts and will kill clojure-lsp silently if it exceeds the limit. It is highly recommended that you increase the Init timeout from 10000 (10s) to e.g. 300000 (5 min). The first scan can easily take over a minute on a bigger project. See Preferences / Languages & Frameworks / Language Server Protocol / Timeouts. If the plugin's icon in the status bar (a circle) turns red, it means starting clojure-lsp failed. Click on it and select Show timeouts - any limits that were exceeded will be in red. Oni # Seems to work reasonably well but couldn't get rename to work reliably https://github.com/onivim/oni Atom # I tried making a client but my hello world attempt didn't seem to work. If someone wants to take this on, I'd be willing to package it here too.","title":"Clients"},{"location":"clients/#clients","text":"Clients are either editors with built in LSP support like Oni or nvim, or an appropriate plugin. Clients are responsible for launching the server, the server is a subprocess of your editor not a daemon. In general, make sure to configure the client to use stdio and a server launch command like ['/usr/local/bin/clojure-lsp'] . If that fails, you may need to have your client launch inside a shell, so use something like ['bash', '-c', '/usr/local/bin/clojure-lsp'] . In windows you probably need to use the clojure-lsp.bat . TIP : If your editor is not started from the terminal then it is possible that its $PATH is quite different from the one in the shell and clojure-lsp will not be able to find the executables it needs, such as clojure and npx . To alleviate that, create a wrapper script that sets the PATH correctly. Make sure that nothing in the script uses stdin / stdout as these are used for communication with the editor and any extra input/output could mess it up. An example script (also remember to make it executable, e.g. chmod u+x <script> ): #!/bin/bash -l if [ ! -e npx ] ; then export PATH = $PATH :/Users/me/.nvm/versions/node/v10.24.1/bin fi exec /usr/local/bin/clojure-lsp","title":"Clients"},{"location":"clients/#emacs","text":"lsp-mode has built in support for clojure-lsp . With use-package , add the following to your emacs config: ( use-package lsp-mode :ensure t :hook (( clojure-mode . lsp ) ( clojurec-mode . lsp ) ( clojurescript-mode . lsp )) :config ;; add paths to your local installation of project mgmt tools, like lein ( setenv \"PATH\" ( concat \"/usr/local/bin\" path-separator ( getenv \"PATH\" ))) ( dolist ( m ' ( clojure-mode clojurec-mode clojurescript-mode clojurex-mode )) ( add-to-list 'lsp-language-id-configuration ` ( , m . \"clojure\" ))) ( setq lsp-clojure-server-command ' ( \"/path/to/clojure-lsp\" ))) ;; Optional: In case `clojure-lsp` is not in your $PATH Optionally you can add lsp-ui for UI feedback and company-mode for completion: ( use-package lsp-ui :ensure t :commands lsp-ui-mode ) ( use-package company :ensure t ) In lsp-mode , lsp-clojure-server-command variable is available to override the command to start the clojure-lsp server, might be necessary to do this on a Windows environment. For a detailed guide on how to configure Emacs with LSP, check here For more lsp-mode clojure settings, check here","title":"Emacs"},{"location":"clients/#visual-studio-code","text":"Calva is a extension for VSCode for Clojure Development that includes clojure-lsp.","title":"Visual Studio Code"},{"location":"clients/#vim","text":"I prefer https://github.com/neoclide/coc.nvim but both http://github.com/autozimu/LanguageClient-neovim and https://github.com/prabirshrestha/vim-lsp work well. See my nvim/init.vim and coc-settings.json Another example of a Neovim Conjure/CoC/clojure-lsp setup can be found on dharrigan's github repository. LanguageClient-neovim can be configure with: Refactorings: function ! Expand ( exp ) abort let l :result = expand ( a :exp ) return l :result == # '' ? '' : \"file://\" . l :result endfunction nnoremap < silent > crcc : call LanguageClient#workspace_executeCommand ( 'cycle-coll' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crth : call LanguageClient#workspace_executeCommand ( 'thread-first' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtt : call LanguageClient#workspace_executeCommand ( 'thread-last' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtf : call LanguageClient#workspace_executeCommand ( 'thread-first-all' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crtl : call LanguageClient#workspace_executeCommand ( 'thread-last-all' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > crml : call LanguageClient#workspace_executeCommand ( 'move-to-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 , input ( 'Binding name: ' ) ] )< CR > nnoremap < silent > cril : call LanguageClient#workspace_executeCommand ( 'introduce-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 , input ( 'Binding name: ' ) ] )< CR > nnoremap < silent > crel : call LanguageClient#workspace_executeCommand ( 'expand-let' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > nnoremap < silent > cram : call LanguageClient#workspace_executeCommand ( 'add-missing-libspec' , [Expand ( '%:p' ), line ( '.' ) - 1 , col ( '.' ) - 1 ] )< CR > initializationOptions can be sent by setting: let g:LanguageClient_settingsPath=\".lsp/settings.json\" Project-local .lsp/settings.json would have content like: { \"initializationOptions\" : { \"source-paths\" : [ \"shared-src\" , \"src\" , \"test\" , \"dashboard/src\" ] , \"macro-defs\" : { \"project.macros/dofor\" : [ \"bindings\" , \"bound-elements\" ]}}} Further refactoring mappings include being able to invoke the (coc-codeaction-*) function to provide actions such as move to let , change coll to map and so on. nmap <silent> <Leader>cr <Plug>(coc-rename) nmap <silent> <Leader>cf <Plug>(coc-references) xmap <silent> <Leader>c <Plug>(coc-codeaction-selected) nmap <silent> <Leader>c <Plug>(coc-codeaction-line) nmap <silent> gd <Plug>(coc-definition)","title":"Vim"},{"location":"clients/#nvim","text":"An very detailed document about how configure Nvim as Clojure IDE using fennel, clojure-lsp and conjure. nvim-fennel-lsp-conjure-as-clojure-ide","title":"Nvim"},{"location":"clients/#sublime-text","text":"Clojure LSP can be installed by first installing the LSP plugin which brings Language Server Protocol support to Sublime Text editor and then following the set-up instructions here to download Clojure LSP and how to configure it in Sublime Text.","title":"Sublime Text"},{"location":"clients/#intellij","text":"Install the LSP Support plugin and configure it to launch clojure-lsp for Clojure/Script files: Go to Preferences / Languages & Frameworks / Language Server Protocol / Server Definitions. Select Raw command . In the Extension field enter clj;cljs;cljc;edn . In the Command field enter the path to the executable, for instance /usr/local/bin/clojure-lsp . BEWARE: The LSP Support plugin has short timeouts and will kill clojure-lsp silently if it exceeds the limit. It is highly recommended that you increase the Init timeout from 10000 (10s) to e.g. 300000 (5 min). The first scan can easily take over a minute on a bigger project. See Preferences / Languages & Frameworks / Language Server Protocol / Timeouts. If the plugin's icon in the status bar (a circle) turns red, it means starting clojure-lsp failed. Click on it and select Show timeouts - any limits that were exceeded will be in red.","title":"Intellij"},{"location":"clients/#oni","text":"Seems to work reasonably well but couldn't get rename to work reliably https://github.com/onivim/oni","title":"Oni"},{"location":"clients/#atom","text":"I tried making a client but my hello world attempt didn't seem to work. If someone wants to take this on, I'd be willing to package it here too.","title":"Atom"},{"location":"development/","text":"clojure-lsp Development # There are several ways of finding and fixing a bug or implementing a new feature: The Clojure Way Create a test for your bug/feature, then implement the code following the test (TDD). Build clojure-lsp using make each time you have made changes, and test it manually in your client. This is the slowest option. Whichever development path you choose: For final testing, it is good to rebuild the binary with make . There are two custom LSP methods clojure/serverInfo/log and clojure/cursorInfo/log . They can assist in debugging. The Clojure Way # With a clojure-lsp + nREPL powered Clojure editor you can modify your editor session's clojure-lsp server using the Clojure REPL. Here's demo video: https://www.youtube.com/watch?v=4UvT0yqBDw8 These are the steps: Configure your editor to use the clojure-lsp executable from this project make - to build the clojure-lsp executable Have your editor restart its clojure-lsp server Issue the clojure-lsp serverInfo command Find the port entry in the output Connect your editors nREPL client to this port Hack away! Seeing is believing. An easy way to convince yourself that you can actually change clojure-lsp mid-flight is to: Modify the server-info function in src/clojure_lsp/handlers.clj Say, you add a :foo :bar entry to the map returned Evaluate the new server-info function definition Issue the clojure-lsp serverInfo command Find :foo :bar in the output You have just modified the LSP server powering your editor while it was running! This is the Clojure way. No recompiling and restarting and reloading. That is some other, non-Clojure, way. The details in how to perform these steps can vary a bit between the various Clojure editors/plugins. Visual Studio Code with Calva # This project comes with Calva configuration to use the clojure-lsp executable built in step 2 above. You can skip step 1. To restart the clojure-lsp server, use the VS Code command Developer: Reload Window The Hack away! step needs to start with you issuing the command Calva: Load Current File and Dependencies . Emacs with CIDER # TBD. PR welcome. Your Favorite Editor # TBD. PR welcome.","title":"Development"},{"location":"development/#clojure-lsp-development","text":"There are several ways of finding and fixing a bug or implementing a new feature: The Clojure Way Create a test for your bug/feature, then implement the code following the test (TDD). Build clojure-lsp using make each time you have made changes, and test it manually in your client. This is the slowest option. Whichever development path you choose: For final testing, it is good to rebuild the binary with make . There are two custom LSP methods clojure/serverInfo/log and clojure/cursorInfo/log . They can assist in debugging.","title":"clojure-lsp Development"},{"location":"development/#the-clojure-way","text":"With a clojure-lsp + nREPL powered Clojure editor you can modify your editor session's clojure-lsp server using the Clojure REPL. Here's demo video: https://www.youtube.com/watch?v=4UvT0yqBDw8 These are the steps: Configure your editor to use the clojure-lsp executable from this project make - to build the clojure-lsp executable Have your editor restart its clojure-lsp server Issue the clojure-lsp serverInfo command Find the port entry in the output Connect your editors nREPL client to this port Hack away! Seeing is believing. An easy way to convince yourself that you can actually change clojure-lsp mid-flight is to: Modify the server-info function in src/clojure_lsp/handlers.clj Say, you add a :foo :bar entry to the map returned Evaluate the new server-info function definition Issue the clojure-lsp serverInfo command Find :foo :bar in the output You have just modified the LSP server powering your editor while it was running! This is the Clojure way. No recompiling and restarting and reloading. That is some other, non-Clojure, way. The details in how to perform these steps can vary a bit between the various Clojure editors/plugins.","title":"The Clojure Way"},{"location":"development/#visual-studio-code-with-calva","text":"This project comes with Calva configuration to use the clojure-lsp executable built in step 2 above. You can skip step 1. To restart the clojure-lsp server, use the VS Code command Developer: Reload Window The Hack away! step needs to start with you issuing the command Calva: Load Current File and Dependencies .","title":"Visual Studio Code with Calva"},{"location":"development/#emacs-with-cider","text":"TBD. PR welcome.","title":"Emacs with CIDER"},{"location":"development/#your-favorite-editor","text":"TBD. PR welcome.","title":"Your Favorite Editor"},{"location":"features/","text":"Features # Above you can find all available features that clojure-lsp provide with examples using Emacs lsp-mode client. Find a function/var definition # Find all references of a function, var, keyword or namespace alias # Show all workspace/project symbols # Show all symbols on current file # Rename symbols # Also, it's possible to live rename symbols on the same buffer with linkedEditingRange feature. Document highlight on hover showing symbol usages # Documentation and clojuredocs integration # Completion # Snippets # Snippets are templates that make it easier to enter repeating code patterns, such as common functions/forms, they are available during completion. Tabstops are defined as $number with $0 as last tabstop. Check all available snippets here name description raw content comment$ Create comment block (comment\\n $0\\n ) condp$ Create condp (condp ${1:pred} ${2:expr}\\n $0) def$ Create def (def ${1:name} $0) defmethod$ Create defmethod (defmethod ${1:name} ${2:match}\\n [${3:args}]\\n $0) defmulti$ Create defmulti (defmulti ${1:name} ${2:dispatch-fn}) defn-$ Create private function (defn%s ${1:name} [$2]\\n $0) defn$ Create public function (defn ${1:foo} [$2]\\n $0) defprotocol$ Create defprotocol (defprotocol ${1:Name}\\n $0) defrecord$ Create defrecord (defrecord ${1:Name} [${2:fields}]\\n ${3:Protocol}\\n $0) deftype$ Create deftype (deftype ${1:Name} [${2:fields}]\\n ${3:Protocol}\\n $0) fn$ Create fn (fn [${1:arg-list}] $0) if$ Create if (if ${1:test-expr}\\n ${2:then-expr}\\n ${3:else-expr}) import$ Create import (:import [${1:package}]) kwargs$ Create keyword args {:keys [${1:keys}] :or {${2:defaults}}} let$ Create let (let [$0]) letfn$ Create letfn (letfn [(${1:name} [${2:args}]\\n $0)]) ns$ Create ns (ns $1\\n $0) require$ Create require (:require [${1:namespace} :as [$0]]) use$ Create use (:use [${1:namespace} :only [$0]]) Custom snippets # User can register additional custom snippets, for more information on how to configure it, check the snippets settings section . Code actions # Name Example Clean namespace require/imports Add require Add known common require Add known common import Add suggested alias require Inline symbol Extract function Move to let Change coll to map,vector,set,list Thread first/all last Create private function Resolve macro as... Code lenses showing symbol references # Format a whole file or range # Signature help # Semantic tokens # Experimental: apply color on client editor for each known token Call hierarchy # Show the incoming or outgoing call hierarchy of a function/variable as a lazy tree Incoming # Show functions that call the current one recursively Outgoing # Show functions that the current one call, recursively Execute command # Commands that client can request. Some code actions use these commands as actions. Refactoring # Commands that change/refactor the code, most of them are available via code actions. Clean namespace * # Add import to namespace # Add missing require * # Cycle privacy of def/defn # Cycle collection (#{}, {}, [], ()) # Change collection to {}, (), #{}, [] # Extract Function * # Create private function * # Inline Symbol * # Expand let # Introduce let # Move expression to let # Thread first expression # Thread last expression # Thread first all * # Thread last all * # Unwind all # Unwind thread # Create test # Resolve macro as * # This code action should be wrapped by the LSP client to provide the missing arguments beside the existing return by the code action: The macro which should resolve as e.g. clojure.core/def The clj-kondo configuration to save the new setting. e.g /home/user/.clj-kondo/config.edn For an example, check how Emacs LSP client handles that. * Available via code actions too Dev # Server information # Return basic information about the server. Cursor information # Return debug information about the element at point. Custom message to client during any server process # During some process, clojure-lsp send messages to client informing some proccess, warning or error. Diagnostics (linter) # All linters besides the ones below come from clj-kondo that clojure-lsp calls under the hood to lint the code and retrieve the analysis to make most of features work. Every linter configuration should be done on clj-kondo side, so anything related to unresolved symbols or unknown macros are probably related to wrong clj-kondo for the project. For more information on how to configure clj-kondo check here . Below you can find the custom linters implemented on clojure-lsp side that uses the :custom-lint-fn from clj-kondo: clojure-lsp/unused-public-var # For more information on how to configure it, check the diagnostics settings section .","title":"Features"},{"location":"features/#features","text":"Above you can find all available features that clojure-lsp provide with examples using Emacs lsp-mode client.","title":"Features"},{"location":"features/#find-a-functionvar-definition","text":"","title":"Find a function/var definition"},{"location":"features/#find-all-references-of-a-function-var-keyword-or-namespace-alias","text":"","title":"Find all references of a function, var, keyword or namespace alias"},{"location":"features/#show-all-workspaceproject-symbols","text":"","title":"Show all workspace/project symbols"},{"location":"features/#show-all-symbols-on-current-file","text":"","title":"Show all symbols on current file"},{"location":"features/#rename-symbols","text":"Also, it's possible to live rename symbols on the same buffer with linkedEditingRange feature.","title":"Rename symbols"},{"location":"features/#document-highlight-on-hover-showing-symbol-usages","text":"","title":"Document highlight on hover showing symbol usages"},{"location":"features/#documentation-and-clojuredocs-integration","text":"","title":"Documentation and clojuredocs integration"},{"location":"features/#completion","text":"","title":"Completion"},{"location":"features/#snippets","text":"Snippets are templates that make it easier to enter repeating code patterns, such as common functions/forms, they are available during completion. Tabstops are defined as $number with $0 as last tabstop. Check all available snippets here name description raw content comment$ Create comment block (comment\\n $0\\n ) condp$ Create condp (condp ${1:pred} ${2:expr}\\n $0) def$ Create def (def ${1:name} $0) defmethod$ Create defmethod (defmethod ${1:name} ${2:match}\\n [${3:args}]\\n $0) defmulti$ Create defmulti (defmulti ${1:name} ${2:dispatch-fn}) defn-$ Create private function (defn%s ${1:name} [$2]\\n $0) defn$ Create public function (defn ${1:foo} [$2]\\n $0) defprotocol$ Create defprotocol (defprotocol ${1:Name}\\n $0) defrecord$ Create defrecord (defrecord ${1:Name} [${2:fields}]\\n ${3:Protocol}\\n $0) deftype$ Create deftype (deftype ${1:Name} [${2:fields}]\\n ${3:Protocol}\\n $0) fn$ Create fn (fn [${1:arg-list}] $0) if$ Create if (if ${1:test-expr}\\n ${2:then-expr}\\n ${3:else-expr}) import$ Create import (:import [${1:package}]) kwargs$ Create keyword args {:keys [${1:keys}] :or {${2:defaults}}} let$ Create let (let [$0]) letfn$ Create letfn (letfn [(${1:name} [${2:args}]\\n $0)]) ns$ Create ns (ns $1\\n $0) require$ Create require (:require [${1:namespace} :as [$0]]) use$ Create use (:use [${1:namespace} :only [$0]])","title":"Snippets"},{"location":"features/#custom-snippets","text":"User can register additional custom snippets, for more information on how to configure it, check the snippets settings section .","title":"Custom snippets"},{"location":"features/#code-actions","text":"Name Example Clean namespace require/imports Add require Add known common require Add known common import Add suggested alias require Inline symbol Extract function Move to let Change coll to map,vector,set,list Thread first/all last Create private function Resolve macro as...","title":"Code actions"},{"location":"features/#code-lenses-showing-symbol-references","text":"","title":"Code lenses showing symbol references"},{"location":"features/#format-a-whole-file-or-range","text":"","title":"Format a whole file or range"},{"location":"features/#signature-help","text":"","title":"Signature help"},{"location":"features/#semantic-tokens","text":"Experimental: apply color on client editor for each known token","title":"Semantic tokens"},{"location":"features/#call-hierarchy","text":"Show the incoming or outgoing call hierarchy of a function/variable as a lazy tree","title":"Call hierarchy"},{"location":"features/#incoming","text":"Show functions that call the current one recursively","title":"Incoming"},{"location":"features/#outgoing","text":"Show functions that the current one call, recursively","title":"Outgoing"},{"location":"features/#execute-command","text":"Commands that client can request. Some code actions use these commands as actions.","title":"Execute command"},{"location":"features/#refactoring","text":"Commands that change/refactor the code, most of them are available via code actions.","title":"Refactoring"},{"location":"features/#clean-namespace","text":"","title":"Clean namespace *"},{"location":"features/#add-import-to-namespace","text":"","title":"Add import to namespace"},{"location":"features/#add-missing-require","text":"","title":"Add missing require *"},{"location":"features/#cycle-privacy-of-defdefn","text":"","title":"Cycle privacy of def/defn"},{"location":"features/#cycle-collection","text":"","title":"Cycle collection (#{}, {}, [], ())"},{"location":"features/#change-collection-to","text":"","title":"Change collection to {}, (), #{}, []"},{"location":"features/#extract-function","text":"","title":"Extract Function *"},{"location":"features/#create-private-function","text":"","title":"Create private function *"},{"location":"features/#inline-symbol","text":"","title":"Inline Symbol *"},{"location":"features/#expand-let","text":"","title":"Expand let"},{"location":"features/#introduce-let","text":"","title":"Introduce let"},{"location":"features/#move-expression-to-let","text":"","title":"Move expression to let"},{"location":"features/#thread-first-expression","text":"","title":"Thread first expression"},{"location":"features/#thread-last-expression","text":"","title":"Thread last expression"},{"location":"features/#thread-first-all","text":"","title":"Thread first all *"},{"location":"features/#thread-last-all","text":"","title":"Thread last all *"},{"location":"features/#unwind-all","text":"","title":"Unwind all"},{"location":"features/#unwind-thread","text":"","title":"Unwind thread"},{"location":"features/#create-test","text":"","title":"Create test"},{"location":"features/#resolve-macro-as","text":"This code action should be wrapped by the LSP client to provide the missing arguments beside the existing return by the code action: The macro which should resolve as e.g. clojure.core/def The clj-kondo configuration to save the new setting. e.g /home/user/.clj-kondo/config.edn For an example, check how Emacs LSP client handles that. * Available via code actions too","title":"Resolve macro as *"},{"location":"features/#dev","text":"","title":"Dev"},{"location":"features/#server-information","text":"Return basic information about the server.","title":"Server information"},{"location":"features/#cursor-information","text":"Return debug information about the element at point.","title":"Cursor information"},{"location":"features/#custom-message-to-client-during-any-server-process","text":"During some process, clojure-lsp send messages to client informing some proccess, warning or error.","title":"Custom message to client during any server process"},{"location":"features/#diagnostics-linter","text":"All linters besides the ones below come from clj-kondo that clojure-lsp calls under the hood to lint the code and retrieve the analysis to make most of features work. Every linter configuration should be done on clj-kondo side, so anything related to unresolved symbols or unknown macros are probably related to wrong clj-kondo for the project. For more information on how to configure clj-kondo check here . Below you can find the custom linters implemented on clojure-lsp side that uses the :custom-lint-fn from clj-kondo:","title":"Diagnostics (linter)"},{"location":"features/#clojure-lspunused-public-var","text":"For more information on how to configure it, check the diagnostics settings section .","title":"clojure-lsp/unused-public-var"},{"location":"installation/","text":"Installation # Below are all available clojure-lsp installation methods, after installed, follow the documentation for your editor's language client. See Clients . Homebrew (MacOS and Linux) # We have a custom tap using the native compiled binaries for users that use homebrew: brew remove clojure-lsp # if you have old clojure-lsp installed via brew brew install clojure-lsp/brew/clojure-lsp-native Script # sudo bash < < ( curl -s https://raw.githubusercontent.com/clojure-lsp/clojure-lsp/master/install ) Nix # clojure-lsp is available in the nixpkgs : nix-shell -p clojure-lsp Arch Linux # clojure-lsp is available in the Arch User Repository . It can be installed using your favorite AUR helper such as yay , yaourt , apacman and pacaur . Here is an example using yay : yay -S clojure-lsp-bin Windows # clojure-lsp is available as a native executable in the Clojure Scoop bucket . You need to install Scoop if you don't have it already. Issue following command to download the clojure-lsp executable. scoop install clojure-lsp Native binary (recommended) # clojure-lsp builds using GraalVM a native executable for each OS: Linux, MacOS and Windows. Manually # The binaries are available on Github releases as clojure-lsp-native-<os>-<arch>.zip , after downloading you just need to unzip it. Embedded jar (Legacy executable) # In Github releases you will find a clojure-lsp file that runs a embedded jar. This should be removed soon, use GraalVM binaries instead. You need java on your $PATH. Grab the latest clojure-lsp from github LATEST Place it in your $PATH with a chmod 755","title":"Installation"},{"location":"installation/#installation","text":"Below are all available clojure-lsp installation methods, after installed, follow the documentation for your editor's language client. See Clients .","title":"Installation"},{"location":"installation/#homebrew-macos-and-linux","text":"We have a custom tap using the native compiled binaries for users that use homebrew: brew remove clojure-lsp # if you have old clojure-lsp installed via brew brew install clojure-lsp/brew/clojure-lsp-native","title":"Homebrew (MacOS and Linux)"},{"location":"installation/#script","text":"sudo bash < < ( curl -s https://raw.githubusercontent.com/clojure-lsp/clojure-lsp/master/install )","title":"Script"},{"location":"installation/#nix","text":"clojure-lsp is available in the nixpkgs : nix-shell -p clojure-lsp","title":"Nix"},{"location":"installation/#arch-linux","text":"clojure-lsp is available in the Arch User Repository . It can be installed using your favorite AUR helper such as yay , yaourt , apacman and pacaur . Here is an example using yay : yay -S clojure-lsp-bin","title":"Arch Linux"},{"location":"installation/#windows","text":"clojure-lsp is available as a native executable in the Clojure Scoop bucket . You need to install Scoop if you don't have it already. Issue following command to download the clojure-lsp executable. scoop install clojure-lsp","title":"Windows"},{"location":"installation/#native-binary-recommended","text":"clojure-lsp builds using GraalVM a native executable for each OS: Linux, MacOS and Windows.","title":"Native binary (recommended)"},{"location":"installation/#manually","text":"The binaries are available on Github releases as clojure-lsp-native-<os>-<arch>.zip , after downloading you just need to unzip it.","title":"Manually"},{"location":"installation/#embedded-jar-legacy-executable","text":"In Github releases you will find a clojure-lsp file that runs a embedded jar. This should be removed soon, use GraalVM binaries instead. You need java on your $PATH. Grab the latest clojure-lsp from github LATEST Place it in your $PATH with a chmod 755","title":"Embedded jar (Legacy executable)"},{"location":"settings/","text":"Settings # clojure-lsp settings are picked up only on server start and can be configured via 4 ways: Project configuration Global configuration LSP InitializationOptions Classpath config paths Project # clojure-lsp will look for project specific settings in a file called .lsp/config.edn . It will search from your project root folder up the directory structure so you can have multiple projects share the same settings. Example: { :cljfmt { :indents { # re \".*\" ns [[ :inner 0 ] [ :inner 1 ]]}} :auto-add-ns-to-new-files? false } Global # For global settings which should work for all the projects using clojure-lsp , you just need to add the same configs to ~/.lsp/config.edn or $XDG_CONFIG_HOME/.lsp/config.edn . For an example of a global config.edn , check here . InitializationOptions # This is specific for an client, where it sends on startup, check LSP spec for more information . This is useful if you are changing a default for a client/editor that will affect all users of that editor. This is an example how Emacs lsp-mode pass custom information. If you are using a client which defines InitializationOptions as a json object, you can use json types instead: keyword -> string or colon-prefixed string ( \"incremental\" or \":incremental\" ) map -> object ( {\"unused-public-ns\": {\"level\": \"info\"}} ) set -> array ( [\"src\" \"test\"] ) vector -> array ( [\"src\" \"test\"] ) Classpath config paths # When starting the server, clojure-lsp will search for a specific path clojure-lsp.exports/<group-id>/<artifact-id>/config.edn for extra configurations in the classpath, only if you set the setting :classpath-config-paths containing that group/artifact . Example: Lib my-org/my-lib could have a clojure-lsp config edn that makes sense for the usages of that lib, making available on the classpath: my-lib/resources/clojure-lsp.exports/my-org/my-lib/config.edn { :cljfmt { :indents { foo [[ :block 0 ]]}}} and then if your project use/has the my-org/my-lib inside your classpath, you could add the setting your-project/.lsp/config.edn { :classpath-config-paths [ \"my-org/my-lib\" ]} And then clojure-lsp will merge the configuration from the lib with the other configurations from your project. This is useful if you have some rule to apply to clojure-lsp for multiple projects, mostly using via API for linting for example, and want to move the common configuration to some place instead of adding to each project that needs that. All settings # You can find all settings and its default here and below the docs for each one: name description default source-paths project-local directories to look for clj/cljc/cljs files, if using deps.edn , project.clj or bb.edn , use :source-aliases instead. #{\"src\" \"test\"} source-aliases Used for deps.edn or project.clj projects, the aliases which clojure-lsp should get the source-paths besides the root level :paths and :extra-paths . Check the source-aliases discovery section below. #{:dev :test} linters clojure-lsp custom linters, check the diagnostics settings section below additional-snippets Additional user snippets to be available during completing, check the snippets section below [] ignore-classpath-directories will not consider clojure files within the directories specified by your classpath. This is needed, for instance, if your build puts artifacts into resources or target that you want lsp to ignore. false lint-project-files-after-startup? Whether to async lint all project only files after startup to make features like List project errors work. true notify-references-on-file-change Whether to update diagnostics of the changed references when editing files, avoiding outdated diagnostics in other files. false use-metadata-for-privacy? Whether to use ^:private metadata for refactorings instead of defn- false :clean Settings related to clean-ns refactoring. Check clean settings below. semantic-tokens? Whether to enable LSP semantic tokens server support for syntax highlighting. true hover arity-on-same-line? Whether to keep the arity on the same line of the function on hover, useful for Emacs users. false hover hide-file-location? Whether to show the full filename and path on hover. false hover clojuredocs Whether to get clojuredocs information on hover, the clojuredocs content is cached. true auto-add-ns-to-new-files? Whether to automatically add the ns form in new blank files. true document-formatting? if true or not present, document formatting is provided. true document-range-formatting? if true or not present, document range formatting is provided. true text-document-sync-kind The sync kind during document changes, if client should send whole buffer or just related changes. Should be :full or :incremental :full dependency-scheme How the dependencies should be linked, jar will make urls compatible with java's JarURLConnection. You can have the client make an lsp extension request of clojure/dependencyContents with the jar uri and the server will return the jar entry's contents. Similar to java clients zip cljfmt-config-path Where to find cljfmt configuration for formatting. A path relative to project root or an absolute path. Use #re for regex inside the cljfmt configuration file. .cljfmt.edn cljfmt If no :cljfmt-config-path is provided, used this for formatting, json encoded configuration for cljfmt {} project-specs A vector of a map with project-path and classpath-cmd , defining how clojure-lsp should find your project classpath. the project-path should be a file and the classpath-cmd the command to run to get the classpath Check Classpath scan section below code-lens segregate-test-references Segregate main references from test references with option to disable true classpath-config-paths List of extra configurations to load from classpath, for more info, check Classpath config paths section. [] cache-path Where to store the project's analysis cache, used to speed up next clojure-lsp startup. A path relative to project root or an absolute path. .lsp/.cache log-path A absolute path to a file where clojure-lsp should log. A JVM tmp path, usually /tmp/clojure-lsp.*.out Classpath scan # clojure-lsp needs to analyze the whole project and its dependencies to understand your code for most features, during the startup clojure-lsp will try to find the classpath of your project to pass to clj-kondo later. You can configure how clojure-lsp should find the classpath with the project-specs setting, check the default here . Supported project types at the moment are: leiningen : If a project.clj is found at the project root, clojure-lsp will run lein classpath . deps : If a deps.edn is found at the project root, clojure-lsp will run clojure -Spath . boot : If a build.boot is found at the project root, clojure-lsp will run boot show --fake-classpath . shadow-cljs : If a shadow-cljs.edn is found at the project root, clojure-lsp will run npx shadow-cljs classpath . babashka : If a bb.edn is found at the project root, clojure-lsp will run bb print-deps --format classpath . Note that it's possible to have more and one project type at the same time e.g. deps + babashka, clojure-lsp will merge the classpath and everything should works fine. Make sure to have these programs available on the PATH environment variable used by your editor, otherwise clojure-lsp will warn about a classpath scan fail, causing a lot of features to not work properly. Alternatively, you can configure the project-specs specific for your project, for example: .lsp/config.edn { :project-specs [{ :project-path \"deps.edn\" :classpath-cmd [ \"clojure\" \"-A:dev\" \"-Spath\" ]}]} Note that clojure-lsp will make this scan to save the cache when: The project has no cache ( .lsp/.cache ) The project deps file ( project.clj for example) changed. The clj-kondo config has changed. Diagnostics (linter) # Default: Check :linters in all-available-settings.edn . clj-kondo # clojure-lsp uses clj-kondo under the hood to lint the code and retrieve the analysis to make most of features work, you don't have to install clj-kondo to make it work. clojure-lsp will use a specific clj-kondo version that can be retrieved via clojure-lsp --version , but make sure you have it properly configured in your .clj-kondo/config.edn file. It has the possible key/values: :level with available values: :off , :on with default value of :on :report-duplicates which will show all linters of the same symbol instead of showing only the first spot. Available values: true , false with default value of true ns-exclude-regex which will exclude the diagnostics/findings for namespaces that match this regex. Example: .lsp/config.edn { :linters { :clj-kondo { :level :on :report-duplicates true :ns-exclude-regex \"some-ns.*\" }}} Note for vim users If you are a (neo)vim user and have [ale](https://github.com/dense-analysis/ale) installed as a plugin, you **should not** have this configured as a linter `let g:ale_linters = {'clojure': ['clj-kondo']}` in your vimrc. Having this linter enabled via `ale` will only conflict with the built-in clj-kondo bundled with clojure-lsp. For more information about all clj-kondo available configurations, check the clj-kondo configuration section Custom clj-kondo hooks # Clojure-lsp register custom linters in clj-kondo, for specifically those linters, configurations should be done on clj-kondo config files, e.g. ( <project>/.clj-kondo/config.edn ), below are the custom linters used: clojure-lsp/unused-public-var # A custom linter that reports public functions/vars not used over the project. It has the possible key/values: :level with available values: :info , :warning , :error or :off with default value of :info . :exclude a whole namespace with #{my-ns} or a specific var #{my-ns/foo} . :exclude-when-defined-by excludes this linter when your var is defined by a macro for example, like #{my-ns/deftest} . Example: .clj-kondo/config.edn { :linters { :clojure-lsp/unused-public-var { :level :warning :exclude # { my-ns/foo my-ns/bar other-ns my-func } :exclude-when-defined-by # { my-ns/defflow }}}} Disable linter # It's not recommended to disable the linter as it provides helpful smart checks/suggestions for your code, even so it's possible via the following config: .lsp/config.edn { :linters { :clj-kondo { :level :off }}} For information on how to troubleshoot the linter, check the troubleshooting section Source paths discovery # Some features require know the available source paths of your project, where your code lives, clojure-lsp has some settings for that. If your project is a lein project, clojure-lsp will scan the project.clj file for :source-paths , :test-paths and the optional source-paths from the specified :source-aliases setting (default #{:dev :test} ), unless you specified :source-paths setting manually. If your project is a deps.edn , clojure-lsp will scan the deps.edn file for :paths , :extra-paths and the paths and extra-paths from the specified :source-aliases setting (default #{:dev :test} ), unless you specified :source-paths setting manually. If your project is not a deps.edn or lein project, a boot project for example, clojure-lsp will use only the :source-paths setting (default #{\"src\" \"test\"} ) which should point to the folders containing your clojure code. Clean # Default: Check :clean in all-available-settings.edn . ns-inner-blocks-indentation # Where to place first require/import following Clojure Style Guide , :same-line , :next-line or :keep . sort # ns # Whether to enable sort of ns children like require,import forms following Clojure Style Guide . require # Whether to enable sort of :require form. import # Whether to enable sort of :import form. refer # Whether to enable sort of :refer form. :max-line-length : the max refers to keep at same line before breaking the line. Default 80 . Snippets # Besides the 19 built-in snippets, it's possible to configure custom additional snippets via :additional-snippets setting: :name the name to use while completing to reach that snippet, preferably with a $ sufix to indicate a snippet. :detail Custom text to show along with the completion name. :snippet The body of the snippet, besides any text it can contains: $1 , $2 , ... as the tabstops representing each place where user may change the content. $0 as the last tabstop. $current-form to replace the current form in the snippet. Example: { :additional-snippets [{ :name \"wrap-let-sexpr$\" :detail \"Wrap current sexpr in let\" :snippet \"(let [$1] $0$current-form)\" }]} when completion is called on the code below with the cursor as | wrap| ( + 1 2 ) It should return a completion item that after applied should result in: ( let [ | ] ( + 1 2 ))","title":"Settings"},{"location":"settings/#settings","text":"clojure-lsp settings are picked up only on server start and can be configured via 4 ways: Project configuration Global configuration LSP InitializationOptions Classpath config paths","title":"Settings"},{"location":"settings/#project","text":"clojure-lsp will look for project specific settings in a file called .lsp/config.edn . It will search from your project root folder up the directory structure so you can have multiple projects share the same settings. Example: { :cljfmt { :indents { # re \".*\" ns [[ :inner 0 ] [ :inner 1 ]]}} :auto-add-ns-to-new-files? false }","title":"Project"},{"location":"settings/#global","text":"For global settings which should work for all the projects using clojure-lsp , you just need to add the same configs to ~/.lsp/config.edn or $XDG_CONFIG_HOME/.lsp/config.edn . For an example of a global config.edn , check here .","title":"Global"},{"location":"settings/#initializationoptions","text":"This is specific for an client, where it sends on startup, check LSP spec for more information . This is useful if you are changing a default for a client/editor that will affect all users of that editor. This is an example how Emacs lsp-mode pass custom information. If you are using a client which defines InitializationOptions as a json object, you can use json types instead: keyword -> string or colon-prefixed string ( \"incremental\" or \":incremental\" ) map -> object ( {\"unused-public-ns\": {\"level\": \"info\"}} ) set -> array ( [\"src\" \"test\"] ) vector -> array ( [\"src\" \"test\"] )","title":"InitializationOptions"},{"location":"settings/#classpath-config-paths","text":"When starting the server, clojure-lsp will search for a specific path clojure-lsp.exports/<group-id>/<artifact-id>/config.edn for extra configurations in the classpath, only if you set the setting :classpath-config-paths containing that group/artifact . Example: Lib my-org/my-lib could have a clojure-lsp config edn that makes sense for the usages of that lib, making available on the classpath: my-lib/resources/clojure-lsp.exports/my-org/my-lib/config.edn { :cljfmt { :indents { foo [[ :block 0 ]]}}} and then if your project use/has the my-org/my-lib inside your classpath, you could add the setting your-project/.lsp/config.edn { :classpath-config-paths [ \"my-org/my-lib\" ]} And then clojure-lsp will merge the configuration from the lib with the other configurations from your project. This is useful if you have some rule to apply to clojure-lsp for multiple projects, mostly using via API for linting for example, and want to move the common configuration to some place instead of adding to each project that needs that.","title":"Classpath config paths"},{"location":"settings/#all-settings","text":"You can find all settings and its default here and below the docs for each one: name description default source-paths project-local directories to look for clj/cljc/cljs files, if using deps.edn , project.clj or bb.edn , use :source-aliases instead. #{\"src\" \"test\"} source-aliases Used for deps.edn or project.clj projects, the aliases which clojure-lsp should get the source-paths besides the root level :paths and :extra-paths . Check the source-aliases discovery section below. #{:dev :test} linters clojure-lsp custom linters, check the diagnostics settings section below additional-snippets Additional user snippets to be available during completing, check the snippets section below [] ignore-classpath-directories will not consider clojure files within the directories specified by your classpath. This is needed, for instance, if your build puts artifacts into resources or target that you want lsp to ignore. false lint-project-files-after-startup? Whether to async lint all project only files after startup to make features like List project errors work. true notify-references-on-file-change Whether to update diagnostics of the changed references when editing files, avoiding outdated diagnostics in other files. false use-metadata-for-privacy? Whether to use ^:private metadata for refactorings instead of defn- false :clean Settings related to clean-ns refactoring. Check clean settings below. semantic-tokens? Whether to enable LSP semantic tokens server support for syntax highlighting. true hover arity-on-same-line? Whether to keep the arity on the same line of the function on hover, useful for Emacs users. false hover hide-file-location? Whether to show the full filename and path on hover. false hover clojuredocs Whether to get clojuredocs information on hover, the clojuredocs content is cached. true auto-add-ns-to-new-files? Whether to automatically add the ns form in new blank files. true document-formatting? if true or not present, document formatting is provided. true document-range-formatting? if true or not present, document range formatting is provided. true text-document-sync-kind The sync kind during document changes, if client should send whole buffer or just related changes. Should be :full or :incremental :full dependency-scheme How the dependencies should be linked, jar will make urls compatible with java's JarURLConnection. You can have the client make an lsp extension request of clojure/dependencyContents with the jar uri and the server will return the jar entry's contents. Similar to java clients zip cljfmt-config-path Where to find cljfmt configuration for formatting. A path relative to project root or an absolute path. Use #re for regex inside the cljfmt configuration file. .cljfmt.edn cljfmt If no :cljfmt-config-path is provided, used this for formatting, json encoded configuration for cljfmt {} project-specs A vector of a map with project-path and classpath-cmd , defining how clojure-lsp should find your project classpath. the project-path should be a file and the classpath-cmd the command to run to get the classpath Check Classpath scan section below code-lens segregate-test-references Segregate main references from test references with option to disable true classpath-config-paths List of extra configurations to load from classpath, for more info, check Classpath config paths section. [] cache-path Where to store the project's analysis cache, used to speed up next clojure-lsp startup. A path relative to project root or an absolute path. .lsp/.cache log-path A absolute path to a file where clojure-lsp should log. A JVM tmp path, usually /tmp/clojure-lsp.*.out","title":"All settings"},{"location":"settings/#classpath-scan","text":"clojure-lsp needs to analyze the whole project and its dependencies to understand your code for most features, during the startup clojure-lsp will try to find the classpath of your project to pass to clj-kondo later. You can configure how clojure-lsp should find the classpath with the project-specs setting, check the default here . Supported project types at the moment are: leiningen : If a project.clj is found at the project root, clojure-lsp will run lein classpath . deps : If a deps.edn is found at the project root, clojure-lsp will run clojure -Spath . boot : If a build.boot is found at the project root, clojure-lsp will run boot show --fake-classpath . shadow-cljs : If a shadow-cljs.edn is found at the project root, clojure-lsp will run npx shadow-cljs classpath . babashka : If a bb.edn is found at the project root, clojure-lsp will run bb print-deps --format classpath . Note that it's possible to have more and one project type at the same time e.g. deps + babashka, clojure-lsp will merge the classpath and everything should works fine. Make sure to have these programs available on the PATH environment variable used by your editor, otherwise clojure-lsp will warn about a classpath scan fail, causing a lot of features to not work properly. Alternatively, you can configure the project-specs specific for your project, for example: .lsp/config.edn { :project-specs [{ :project-path \"deps.edn\" :classpath-cmd [ \"clojure\" \"-A:dev\" \"-Spath\" ]}]} Note that clojure-lsp will make this scan to save the cache when: The project has no cache ( .lsp/.cache ) The project deps file ( project.clj for example) changed. The clj-kondo config has changed.","title":"Classpath scan"},{"location":"settings/#diagnostics-linter","text":"Default: Check :linters in all-available-settings.edn .","title":"Diagnostics (linter)"},{"location":"settings/#clj-kondo","text":"clojure-lsp uses clj-kondo under the hood to lint the code and retrieve the analysis to make most of features work, you don't have to install clj-kondo to make it work. clojure-lsp will use a specific clj-kondo version that can be retrieved via clojure-lsp --version , but make sure you have it properly configured in your .clj-kondo/config.edn file. It has the possible key/values: :level with available values: :off , :on with default value of :on :report-duplicates which will show all linters of the same symbol instead of showing only the first spot. Available values: true , false with default value of true ns-exclude-regex which will exclude the diagnostics/findings for namespaces that match this regex. Example: .lsp/config.edn { :linters { :clj-kondo { :level :on :report-duplicates true :ns-exclude-regex \"some-ns.*\" }}} Note for vim users If you are a (neo)vim user and have [ale](https://github.com/dense-analysis/ale) installed as a plugin, you **should not** have this configured as a linter `let g:ale_linters = {'clojure': ['clj-kondo']}` in your vimrc. Having this linter enabled via `ale` will only conflict with the built-in clj-kondo bundled with clojure-lsp. For more information about all clj-kondo available configurations, check the clj-kondo configuration section","title":"clj-kondo"},{"location":"settings/#custom-clj-kondo-hooks","text":"Clojure-lsp register custom linters in clj-kondo, for specifically those linters, configurations should be done on clj-kondo config files, e.g. ( <project>/.clj-kondo/config.edn ), below are the custom linters used:","title":"Custom clj-kondo hooks"},{"location":"settings/#clojure-lspunused-public-var","text":"A custom linter that reports public functions/vars not used over the project. It has the possible key/values: :level with available values: :info , :warning , :error or :off with default value of :info . :exclude a whole namespace with #{my-ns} or a specific var #{my-ns/foo} . :exclude-when-defined-by excludes this linter when your var is defined by a macro for example, like #{my-ns/deftest} . Example: .clj-kondo/config.edn { :linters { :clojure-lsp/unused-public-var { :level :warning :exclude # { my-ns/foo my-ns/bar other-ns my-func } :exclude-when-defined-by # { my-ns/defflow }}}}","title":"clojure-lsp/unused-public-var"},{"location":"settings/#disable-linter","text":"It's not recommended to disable the linter as it provides helpful smart checks/suggestions for your code, even so it's possible via the following config: .lsp/config.edn { :linters { :clj-kondo { :level :off }}} For information on how to troubleshoot the linter, check the troubleshooting section","title":"Disable linter"},{"location":"settings/#source-paths-discovery","text":"Some features require know the available source paths of your project, where your code lives, clojure-lsp has some settings for that. If your project is a lein project, clojure-lsp will scan the project.clj file for :source-paths , :test-paths and the optional source-paths from the specified :source-aliases setting (default #{:dev :test} ), unless you specified :source-paths setting manually. If your project is a deps.edn , clojure-lsp will scan the deps.edn file for :paths , :extra-paths and the paths and extra-paths from the specified :source-aliases setting (default #{:dev :test} ), unless you specified :source-paths setting manually. If your project is not a deps.edn or lein project, a boot project for example, clojure-lsp will use only the :source-paths setting (default #{\"src\" \"test\"} ) which should point to the folders containing your clojure code.","title":"Source paths discovery"},{"location":"settings/#clean","text":"Default: Check :clean in all-available-settings.edn .","title":"Clean"},{"location":"settings/#ns-inner-blocks-indentation","text":"Where to place first require/import following Clojure Style Guide , :same-line , :next-line or :keep .","title":"ns-inner-blocks-indentation"},{"location":"settings/#sort","text":"","title":"sort"},{"location":"settings/#ns","text":"Whether to enable sort of ns children like require,import forms following Clojure Style Guide .","title":"ns"},{"location":"settings/#require","text":"Whether to enable sort of :require form.","title":"require"},{"location":"settings/#import","text":"Whether to enable sort of :import form.","title":"import"},{"location":"settings/#refer","text":"Whether to enable sort of :refer form. :max-line-length : the max refers to keep at same line before breaking the line. Default 80 .","title":"refer"},{"location":"settings/#snippets","text":"Besides the 19 built-in snippets, it's possible to configure custom additional snippets via :additional-snippets setting: :name the name to use while completing to reach that snippet, preferably with a $ sufix to indicate a snippet. :detail Custom text to show along with the completion name. :snippet The body of the snippet, besides any text it can contains: $1 , $2 , ... as the tabstops representing each place where user may change the content. $0 as the last tabstop. $current-form to replace the current form in the snippet. Example: { :additional-snippets [{ :name \"wrap-let-sexpr$\" :detail \"Wrap current sexpr in let\" :snippet \"(let [$1] $0$current-form)\" }]} when completion is called on the code below with the cursor as | wrap| ( + 1 2 ) It should return a completion item that after applied should result in: ( let [ | ] ( + 1 2 ))","title":"Snippets"},{"location":"troubleshooting/","text":"Troubleshooting # Server log # clojure-lsp logs most of what is doing to a file which location could be found: on :log-path if specified in your clojure-lsp config, for example: {:log-path \"/tmp/clojure-lsp.out\"} Auto generated every server start on /tmp/clojure-lsp.<TIMESTAMP>.out Client<->Server log # All LSP clients should provide a way to get the jsonrpc logs between client and server, this helps debug the requests and responses content and time. Check below how to get the logs for most used clients: Emacs/lsp-mode VSCode/Calva Server is not initializing # Make sure you have the most recent version of clojure-lsp Check if the executable is working running it from the command line, it should start up and start reading from stdin. Type {}\\n\\n and you should get something like: $ clojure-lsp {} Apr 12, 2019 7:07:02 AM org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer fireError SEVERE: Missing header Content-Length in input \"{} \" java.lang.IllegalStateException: Missing header Content-Length in input \"{}\"\"\"\" \"\"\" If that is ok, clojure-lsp logs to /tmp/clojure-lsp.*.out , so watch that file and start your editor. LSP Clients also generally have a way to trace server interactions. Turn that on and attach both server and client logs to an issue if it's not obvious what's going on. For example, if you are using neovim with CoC , first ensure that trace.server is set to verbose in your coc-settings.json file, e.g., \"languageserver\" : { \"clojure-lsp\" : { \"command\" : \"clojure-lsp\" , \"filetypes\" : [ \"clojure\" ], \"disableDiagnostics\" : false , \"rootPatterns\" : [ \"deps.edn\" , \"project.clj\" ], \"additionalSchemes\" : [ \"jar\" , \"zipfile\" ], \"trace.server\" : \"verbose\" , \"initializationOptions\" : { \"project-specs\" : [{ \"project-path\" : \"deps.edn\" , \"classpath-cmd\" : [ \"clj\" , \"-Spath\" ] }], \"use-metadata-for-privacy?\" : true , \"ignore-classpath-directories\" : true } } } Then, once vim has loaded (and clojure-lsp has initialised), you can issue this command: :CocCommand workspace.showOutput This will show the JSON request/response bodies that go between vim and clojure-lsp. Please capture that information if you need help in tracking down the problem you are experiencing (either by reporting github issues, or talking with someone in Slack/Discord or whatever...) Some features are not working # clojure-lsp uses clj-kondo to scan the classpath during server initialize for most features work, so make sure you don't see any \"Error while looking up classpath...\" on clojure-lsp log file. Please note that clojure-lsp comes bundled with clj-kondo , so you do not have to install it separately. For more information, check the Classpath scan settings section. Classpath scan error # By default clojure-lsp knows how to scan most common clojure projects using the following rules: If the project root has a project.clj file, it'll run lein classpath to get the classpath. If the project root has a deps.edn file, it'll run clojure -Spath to get the classpath. If the project root has a build.boot file, it'll run boot show --fake-classpath to get the classpath. If the project root has a shadow-cljs.edn file, it'll run npx shadow-cljs classpath to get the classpath. If your project doesn't follow the above rules or you need a custom command to get the classpath you need to configure the project-specs clojure-lsp setting, for more details check the settings section . Folders not being analyzed # By default clojure-lsp searches src and test for clj* files to read into an index. If the definition lives under a different source dir, you can define the src-paths setting, for more details check the settings section . It is also important to get your project-root correct in your client otherwise the source paths will not be found, check the project-root via your LSP client. Wrong diagnostics/lint # clojure-lsp persist the external jars analysis in a .lsp/sqlite.db file, if you have issues with some specific feature, try to remove that file and restart the server. clojure-lsp use clj-kondo to lint and cache in a .clj-kondo/.cache dir, try to remove that file as well if you think it's not linting correctly If you have issues with macros, double check your clj-kondo config . Missing Add require... on code actions when using CoC and (neo)vim # If you find, when executing the command (coc-codeaction-line) (or (coc-codeaction-selected) or (coc-codeaction-cursor) ), that you aren't getting back all of the code actions you might expect, please ensure that you have, in your coc-settings.json the line disableDiagnostics set to false or better yet, don't have the line there at all :-) MacOS # In some version of MacOS, Apple restrict the binary to run, to fix that run: xattr -d com.apple.quarantine /path/to/clojure-lsp","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#server-log","text":"clojure-lsp logs most of what is doing to a file which location could be found: on :log-path if specified in your clojure-lsp config, for example: {:log-path \"/tmp/clojure-lsp.out\"} Auto generated every server start on /tmp/clojure-lsp.<TIMESTAMP>.out","title":"Server log"},{"location":"troubleshooting/#client-server-log","text":"All LSP clients should provide a way to get the jsonrpc logs between client and server, this helps debug the requests and responses content and time. Check below how to get the logs for most used clients: Emacs/lsp-mode VSCode/Calva","title":"Client&lt;-&gt;Server log"},{"location":"troubleshooting/#server-is-not-initializing","text":"Make sure you have the most recent version of clojure-lsp Check if the executable is working running it from the command line, it should start up and start reading from stdin. Type {}\\n\\n and you should get something like: $ clojure-lsp {} Apr 12, 2019 7:07:02 AM org.eclipse.lsp4j.jsonrpc.json.StreamMessageProducer fireError SEVERE: Missing header Content-Length in input \"{} \" java.lang.IllegalStateException: Missing header Content-Length in input \"{}\"\"\"\" \"\"\" If that is ok, clojure-lsp logs to /tmp/clojure-lsp.*.out , so watch that file and start your editor. LSP Clients also generally have a way to trace server interactions. Turn that on and attach both server and client logs to an issue if it's not obvious what's going on. For example, if you are using neovim with CoC , first ensure that trace.server is set to verbose in your coc-settings.json file, e.g., \"languageserver\" : { \"clojure-lsp\" : { \"command\" : \"clojure-lsp\" , \"filetypes\" : [ \"clojure\" ], \"disableDiagnostics\" : false , \"rootPatterns\" : [ \"deps.edn\" , \"project.clj\" ], \"additionalSchemes\" : [ \"jar\" , \"zipfile\" ], \"trace.server\" : \"verbose\" , \"initializationOptions\" : { \"project-specs\" : [{ \"project-path\" : \"deps.edn\" , \"classpath-cmd\" : [ \"clj\" , \"-Spath\" ] }], \"use-metadata-for-privacy?\" : true , \"ignore-classpath-directories\" : true } } } Then, once vim has loaded (and clojure-lsp has initialised), you can issue this command: :CocCommand workspace.showOutput This will show the JSON request/response bodies that go between vim and clojure-lsp. Please capture that information if you need help in tracking down the problem you are experiencing (either by reporting github issues, or talking with someone in Slack/Discord or whatever...)","title":"Server is not initializing"},{"location":"troubleshooting/#some-features-are-not-working","text":"clojure-lsp uses clj-kondo to scan the classpath during server initialize for most features work, so make sure you don't see any \"Error while looking up classpath...\" on clojure-lsp log file. Please note that clojure-lsp comes bundled with clj-kondo , so you do not have to install it separately. For more information, check the Classpath scan settings section.","title":"Some features are not working"},{"location":"troubleshooting/#classpath-scan-error","text":"By default clojure-lsp knows how to scan most common clojure projects using the following rules: If the project root has a project.clj file, it'll run lein classpath to get the classpath. If the project root has a deps.edn file, it'll run clojure -Spath to get the classpath. If the project root has a build.boot file, it'll run boot show --fake-classpath to get the classpath. If the project root has a shadow-cljs.edn file, it'll run npx shadow-cljs classpath to get the classpath. If your project doesn't follow the above rules or you need a custom command to get the classpath you need to configure the project-specs clojure-lsp setting, for more details check the settings section .","title":"Classpath scan error"},{"location":"troubleshooting/#folders-not-being-analyzed","text":"By default clojure-lsp searches src and test for clj* files to read into an index. If the definition lives under a different source dir, you can define the src-paths setting, for more details check the settings section . It is also important to get your project-root correct in your client otherwise the source paths will not be found, check the project-root via your LSP client.","title":"Folders not being analyzed"},{"location":"troubleshooting/#wrong-diagnosticslint","text":"clojure-lsp persist the external jars analysis in a .lsp/sqlite.db file, if you have issues with some specific feature, try to remove that file and restart the server. clojure-lsp use clj-kondo to lint and cache in a .clj-kondo/.cache dir, try to remove that file as well if you think it's not linting correctly If you have issues with macros, double check your clj-kondo config .","title":"Wrong diagnostics/lint"},{"location":"troubleshooting/#missing-add-require-on-code-actions-when-using-coc-and-neovim","text":"If you find, when executing the command (coc-codeaction-line) (or (coc-codeaction-selected) or (coc-codeaction-cursor) ), that you aren't getting back all of the code actions you might expect, please ensure that you have, in your coc-settings.json the line disableDiagnostics set to false or better yet, don't have the line there at all :-)","title":"Missing Add require... on code actions when using CoC and (neo)vim"},{"location":"troubleshooting/#macos","text":"In some version of MacOS, Apple restrict the binary to run, to fix that run: xattr -d com.apple.quarantine /path/to/clojure-lsp","title":"MacOS"}]}